<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.13">
  <POU Name="UnicodeUtf16StringAssertionTests" Id="{5235141c-f312-4a53-b189-d6fe140e7490}" SpecialFunc="None">
    <Declaration><![CDATA[
(*
short summary
==================
This class tests all methods of Unicode string assertions
with various UTF-16 string combinations as input and checks expected 
outputs are satisfied or not

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

methods and properties
======================

*)


FUNCTION_BLOCK UnicodeUtf16StringAssertionTests EXTENDS AbstractAssertorTest
VAR

END_VAR
VAR CONSTANT
	(* prefix to unify the test names *)
	TEST_NAME_PREFIX :STRING := 'assert.string.unicode(utf16).';
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[THIS^.runIsEmpty();
THIS^.runIsNotEmpty();
THIS^.runContains();
THIS^.runContainsNo();
THIS^.runEndsWith();
THIS^.runStartsWith();
THIS^.runIsEqualTo();
THIS^.runIsNotEqualTo();
THIS^.runLengthIsBetween();
THIS^.runLengthIsExact();
THIS^.runLengthIsMax();
THIS^.runLengthIsMin();
]]></ST>
    </Implementation>
    <Folder Name="contains" Id="{f6e3cecb-db52-4b73-947d-d1b83f6abf5f}">
      <Folder Name="ignoreCase" Id="{124f87d3-8a36-4450-8a4f-0ac1746a8774}" />
    </Folder>
    <Folder Name="containsNo" Id="{27536fe0-e7f7-486c-b597-ad5de6464736}">
      <Folder Name="ignoreCase" Id="{7a3df2a8-520a-40f2-966e-0a0ab7dbac88}" />
    </Folder>
    <Folder Name="endsWith" Id="{ffa7dfd7-c9fb-4fc2-ab49-fe8b768a4873}">
      <Folder Name="ignoreCase" Id="{919ef1ff-4142-42ac-9748-86c8f50b59d4}" />
      <Folder Name="trim" Id="{e58edf1c-eee0-4380-85bd-3f0ecae3e467}" />
    </Folder>
    <Folder Name="internal" Id="{adac3b82-94b2-4298-b981-47dcf43a8367}" />
    <Folder Name="isEmpty" Id="{e323b476-3934-4b7c-ad1d-83dd2e2635c9}" />
    <Folder Name="isEqualTo" Id="{67bd5b7b-087b-480b-a668-aaa26ab9406b}">
      <Folder Name="ignoreCase" Id="{bb84c911-d827-4758-a82c-4803a09fee04}" />
    </Folder>
    <Folder Name="isNotEmpty" Id="{014ff201-5ca2-40ea-9b20-14fadc13ba14}" />
    <Folder Name="isNotEqualTo" Id="{583e274c-3291-45ad-9e23-89cf8440e3f9}">
      <Folder Name="ignoreCase" Id="{14c42ac1-4275-45fd-a672-7f147e4ff693}" />
    </Folder>
    <Folder Name="lengthIsBetween" Id="{8e92e0fd-92c8-4bde-b51d-3df86ac34adb}" />
    <Folder Name="lengthIsExact" Id="{f9c8422b-641a-45fb-a128-b9dce9ed404d}" />
    <Folder Name="lengthIsMax" Id="{538f610e-afc7-4b49-9348-ab78c1efc2b0}" />
    <Folder Name="lengthIsMin" Id="{600e75ca-92d9-45f3-8b3c-f4c1f05f44ad}" />
    <Folder Name="startsWith" Id="{b2fe2463-21df-484d-8448-f44e36e3a71e}">
      <Folder Name="ignoreCase" Id="{622e2d68-37f8-4e79-9815-b20db3bf729e}" />
      <Folder Name="trim" Id="{7cd7ed5e-05f2-4cd0-881f-274097237175}" />
    </Folder>
    <Method Name="getTestNameFor" Id="{9a11f2fb-ee55-48e8-a652-323e813bfb43}" FolderPath="internal\">
      <Declaration><![CDATA[(*

short summary
==================
This test method is a helper function to create a unified test name

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD PROTECTED getTestNameFor :Tc2_System.T_MaxString
VAR_INPUT
	(* name of the method to test, to create a unified test name *)
	nameOfMethodToTest	:Tc2_System.T_MaxString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getTestNameFor := Tc2_Standard.CONCAT(THIS^.TEST_NAME_PREFIX, nameOfMethodToTest);]]></ST>
      </Implementation>
    </Method>
    <Method Name="runContains" Id="{6a47b0dd-8f99-45d5-8b35-9361576ea443}" FolderPath="contains\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.contains``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runContains : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('contains')));

THIS^.testContains(
	stringToTest := "",
	expectedString := ""
);
THIS^.testContains(
	stringToTest := "not empty",
	expectedString := ""
);
THIS^.testContains(
	stringToTest := "",
	expectedString := "not empty"
);
THIS^.testContains(
	stringToTest := "not empty",
	expectedString := "not empty"
);
THIS^.testContains(
	stringToTest := "{|}~",
	expectedString := "3649213469328"
);
THIS^.testContains(
	stringToTest := "1one!",
	expectedString := "1"
);
THIS^.testContains(
	stringToTest := "1one!",
	expectedString := "one"
);
THIS^.testContains(
	stringToTest := "1one!",
	expectedString := "!"
);
THIS^.testContains(
	stringToTest := "$0040$n$t$$$"$'",
	expectedString := "$n$t"
);
THIS^.testContains(
	stringToTest := "frontmiddleback",
	expectedString := "back"
);
THIS^.testContains(
	stringToTest := "frontmiddleback",
	expectedString := "frontmiddlebackfront"
);
THIS^.testContains(
	stringToTest := "backfrontmiddle",
	expectedString := "backmiddle"
);
THIS^.testContains(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y"
);
THIS^.testContains(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x"
);
THIS^.testContains(
	stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)",
	expectedString := "∑ f(i) = ∏ g(i)"
);
THIS^.testContains(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ"
);
THIS^.testContains(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ ⇒ (A ⇔ B)"
);
THIS^.testContains(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "2H₂ + O₂ ⇌ 2H₂O"
);
THIS^.testContains(
	stringToTest := "ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]",
	expectedString := "ˈnæʃənəl fəˈnɛtık "
);
THIS^.testContains(
	stringToTest := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €",
	expectedString := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €"
);
THIS^.testContains(
	stringToTest := "Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,",
	expectedString := "τὴν κόψη τοῦ σπαθ"
);
THIS^.testContains(
	stringToTest := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად, რომელიც გაიმართება",
	expectedString := "გაიაროთ რეგისტრაცია Unicode-ის გაიმართება"
);
THIS^.testContains(
	stringToTest := "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в",
	expectedString := "Международную Конференцию по Unicode, которая"
);
THIS^.testContains(
	stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา ",
	expectedString := "สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา  " 
);
THIS^.testContains(
	stringToTest := " ሰማይ አይታረስ ንጉሥ አይከሰਸ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።",
	expectedString := "አይታረስ ንጉሥ አይከሰስ። ብላ በቆመጠኝ።"
);
THIS^.testContains(
	stringToTest := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ",
	expectedString := "ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ"
);
THIS^.testContains(
	stringToTest := "⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞",
	expectedString := "⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋"
);
THIS^.testContains(
	stringToTest := "╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳",
	expectedString := "╦══╗  ┌──┬──┐  ╭──╦══╗"
);
THIS^.testContainsIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "CASE"
);
THIS^.testContainsIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "case"
);
THIS^.testContainsIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "case"
);
THIS^.testContainsIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "CASE"
);
THIS^.testContainsIgnoreCase(
	stringToTest := "lower",
	expectedString := "UPPER"
);
THIS^.testContainsIgnoreCase(
	stringToTest := "UPPERCASE⌷←⍳→⍴∆∇⊃‾⍎⍕⌈",
	expectedString := "case⌷←⍳→⍴∆∇⊃‾⍎⍕⌈"
);
THIS^.testContainsIgnoreCase(
	stringToTest := "UPPERCASE((V⍳V)=⍳⍴V)/V←,V",
	expectedString := "case((V⍳V)=⍳⍴V)/V←"
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runContainsNo" Id="{c50f8790-b2f3-43a1-a1a1-19c3c0ab39e6}" FolderPath="containsNo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.containsNo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runContainsNo : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('containsNo')));

THIS^.testContainsNo(
	stringToTest := "",
	expectedString := ""
);
THIS^.testContainsNo(
	stringToTest := "not empty",
	expectedString := ""
);
THIS^.testContainsNo(
	stringToTest := "",
	expectedString := "not empty"
);
THIS^.testContainsNo(
	stringToTest := "not empty",
	expectedString := "not empty"
);
THIS^.testContainsNo(
	stringToTest := "{|}~",
	expectedString := "3649213469328"
);
THIS^.testContainsNo(
	stringToTest := "1one!",
	expectedString := "1"
);
THIS^.testContainsNo(
	stringToTest := "1one!",
	expectedString := "one"
);
THIS^.testContainsNo(
	stringToTest := "1one!",
	expectedString := "!"
);
THIS^.testContainsNo(
	stringToTest := "$0040$n$t$$$"$"",
	expectedString := "$n$t"
);
THIS^.testContainsNo(
	stringToTest := "frontmiddleback",
	expectedString := "back"
);
THIS^.testContainsNo(
	stringToTest := "frontmiddleback",
	expectedString := "frontmiddlebackfront"
);
THIS^.testContainsNo(
	stringToTest := "backfrontmiddle",
	expectedString := "backmiddle"
);
THIS^.testContainsNo(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y"
);
THIS^.testContainsNo(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x"
);
THIS^.testContainsNo(
	stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)",
	expectedString := "∑ f(i) = ∏ g(i)"
);
THIS^.testContainsNo(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ"
);
THIS^.testContainsNo(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ ⇒ (A ⇔ B)"
);
THIS^.testContainsNo(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "2H₂ + O₂ ⇌ 2H₂O"
);
THIS^.testContainsNo(
	stringToTest := "ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]",
	expectedString := "ˈnæʃənəl fəˈnɛtık "
);
THIS^.testContainsNo(
	stringToTest := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €",
	expectedString := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €"
);
THIS^.testContainsNo(
	stringToTest := "Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,",
	expectedString := "τὴν κόψη τοῦ σπαθ"
);
THIS^.testContainsNo(
	stringToTest := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად, რომელიც გაიმართება",
	expectedString := "გაიაროთ რეგისტრაცია Unicode-ის გაიმართება"
);
THIS^.testContainsNo(
	stringToTest := "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в",
	expectedString := "Международную Конференцию по Unicode, которая"
);
THIS^.testContainsNo(
	stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา ",
	expectedString := "สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา  " 
);
THIS^.testContainsNo(
	stringToTest := " ሰማይ አይታረስ ንጉሥ አይከሰਸ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።",
	expectedString := "አይታረስ ንጉሥ አይከሰስ። ብላ በቆመጠኝ።"
);
THIS^.testContainsNo(
	stringToTest := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ",
	expectedString := "ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ"
);
THIS^.testContainsNo(
	stringToTest := "⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞",
	expectedString := "⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋"
);
THIS^.testContainsNo(
	stringToTest := "╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳",
	expectedString := "╦══╗  ┌──┬──┐  ╭──╦══╗"
);

THIS^.testContainsNoIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "CASE"
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "case"
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "case"
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "CASE"
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := "lower",
	expectedString := "UPPER"
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := "UPPERCASE⌷←⍳→⍴∆∇⊃‾⍎⍕⌈",
	expectedString := "case⌷←⍳→⍴∆∇⊃‾⍎⍕⌈"
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := "UPPERCASE((V⍳V)=⍳⍴V)/V←,V",
	expectedString := "case((V⍳V)=⍳⍴V)/V←"
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runEndsWith" Id="{3c11c2e6-042c-4f54-b85c-c033bd116ef5}" FolderPath="endsWith\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.endsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runEndsWith : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('endsWith')));

THIS^.testEndsWith(
	stringToTest := "",
	expectedString := ""
);
THIS^.testEndsWith(
	stringToTest := "not empty",
	expectedString := ""
);
THIS^.testEndsWith(
	stringToTest := "",
	expectedString := "not empty"
);
THIS^.testEndsWith(
	stringToTest := "not empty",
	expectedString := "not empty"
);
THIS^.testEndsWith(
	stringToTest := "{|}~",
	expectedString := "3649213469328"
);
THIS^.testEndsWith(
	stringToTest := "1one!",
	expectedString := "1"
);
THIS^.testEndsWith(
	stringToTest := "1one!",
	expectedString := "one"
);
THIS^.testEndsWith(
	stringToTest := "1one!",
	expectedString := "!"
);
THIS^.testEndsWith(
	stringToTest := "$0040$n$t$$$"$"",
	expectedString := "$n$t"
);
THIS^.testEndsWith(
	stringToTest := "$0040$$$"$"$n$t",
	expectedString := "$n$t"
);
THIS^.testEndsWith(
	stringToTest := "frontmiddleback",
	expectedString := "back"
);
THIS^.testEndsWith(
	stringToTest := "frontmiddleback",
	expectedString := "frontmiddlebackfront"
);
THIS^.testEndsWith(
	stringToTest := "backfrontmiddle",
	expectedString := "backmiddle"
);
THIS^.testEndsWith(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y"
);
THIS^.testEndsWith(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x"
);
THIS^.testEndsWith(
	stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)",
	expectedString := "α ∧ ¬β = ¬(¬α ∨ β)"
);
THIS^.testEndsWith(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm"
);
THIS^.testEndsWith(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ ⇒ (A ⇔ B)"
);
THIS^.testEndsWith(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "2H₂ + O₂ ⇌ 2H₂O"
);
THIS^.testEndsWith(
	stringToTest := "ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]ˈnæʃənəl fəˈnɛtık ",
	expectedString := "ˈnæʃənəl fəˈnɛtık "
);
THIS^.testEndsWith(
	stringToTest := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €",
	expectedString := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €"
);
THIS^.testEndsWith(
	stringToTest := "Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,",
	expectedString := "τὴν κόψη τοῦ σπαθ"
);
THIS^.testEndsWith(
	stringToTest := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად, რომელიც გაიმართება",
	expectedString := "რომელიც გაიმართება"
);
THIS^.testEndsWith(
	stringToTest := "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в",
	expectedString := "Международную Конференцию по Unicode, которая"
);
THIS^.testEndsWith(
	stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา ",
	expectedString := "สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา " 
);
THIS^.testEndsWith(
	stringToTest := " ሰማይ አይታረስ ንጉሥ አይከሰਸ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።",
	expectedString := "አይታረስ ንጉሥ አይከሰስ። በቆመጠኝ።"
);
THIS^.testEndsWith(
	stringToTest := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ",
	expectedString := "ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ"
);
THIS^.testEndsWith(
	stringToTest := "⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞",
	expectedString := "⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙"
);
THIS^.testEndsWith(
	stringToTest := "╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳",
	expectedString := "┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳"
);

THIS^.testEndsWithIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "CASE"
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "case"
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "case"
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "CASE"
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := "lower",
	expectedString := "UPPER"
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := "UPPERCASE⌷←⍳→⍴∆∇⊃‾⍎⍕⌈",
	expectedString := "case⌷←⍳→⍴∆∇⊃‾⍎⍕⌈"
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := "UPPERCASE((V⍳V)=⍳⍴V)/V←,V",
	expectedString := "case((V⍳V)=⍳⍴V)/V←"
);

THIS^.testEndsWithTrim(
	stringToTest := "frontmiddleback$t",
	expectedString := "back"
);
THIS^.testEndsWithTrim(
	stringToTest := "frontmiddleback",
	expectedString := "back$t"
);
THIS^.testEndsWithTrim(
	stringToTest := "frontmiddleback$0020",
	expectedString := "back"
);
THIS^.testEndsWithTrim(
	stringToTest := "frontmiddleback",
	expectedString := "back$0020"
);
THIS^.testEndsWithTrim(
	stringToTest := "frontmiddleback$t$n$r$p$l",
	expectedString := "back$r$t$n$l$p$0020"
);
THIS^.testEndsWithTrim(
	stringToTest := "frontmiddleback$t$n$r$p$l",
	expectedString := "back$t$n$r$p$l$0020"
);
THIS^.testEndsWithTrim(
	stringToTest := "frontmiddleback⌷←⍳→⍴∆∇⊃‾⍎$t$n$r$p$l",
	expectedString := "back⌷←⍳→⍴∆∇⊃‾⍎"
);
THIS^.testEndsWithTrim(
	stringToTest := "frontmiddleback⌷←⍳→⍴∆∇⊃‾⍎$t$n$r$p$l",
	expectedString := "back⌷→⍴∆∇⊃‾⍎"
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runIsEmpty" Id="{7b885508-5186-4b16-ad63-a54f29ebff51}" FolderPath="isEmpty\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.IsEmpty``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runIsEmpty : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('IsEmpty')));

THIS^.testIsEmpty(
	stringToTest := ""
);
THIS^.testIsEmpty(
	stringToTest := "not empty"
);
THIS^.testIsEmpty(
	stringToTest := "{|}~"
);
THIS^.testIsEmpty(
	stringToTest := "3649213469328"
);
THIS^.testIsEmpty(
	stringToTest := "1one!"
);
THIS^.testIsEmpty(
	stringToTest := "$0040$n$t$$$"$""
);
THIS^.testIsEmpty(
	stringToTest := "$n$t"
);
THIS^.testIsEmpty(
	stringToTest := "frontmiddleback"
);
THIS^.testIsEmpty(
	stringToTest := "backfrontmiddle"
);
THIS^.testIsEmpty(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y"
);
THIS^.testIsEmpty(
	stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)",
);
THIS^.testIsEmpty(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
);
THIS^.testIsEmpty(
	stringToTest := "ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]",
);
THIS^.testIsEmpty(
	stringToTest := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €",
);
THIS^.testIsEmpty(
	stringToTest := "Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,",
);
THIS^.testIsEmpty(
	stringToTest := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად, რომელიც გაიმართება",
);
THIS^.testIsEmpty(
	stringToTest := "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в",
);
THIS^.testIsEmpty(
	stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา ",
);
THIS^.testIsEmpty(
	stringToTest := " ሰማይ አይታረስ ንጉሥ አይከሰስ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።",
);
THIS^.testIsEmpty(
	stringToTest := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ",
);
THIS^.testIsEmpty(
	stringToTest := "⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞",
);
THIS^.testIsEmpty(
	stringToTest := "╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳",
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runIsEqualTo" Id="{90c47372-f56e-4fd8-949a-e604086443f0}" FolderPath="isEqualTo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runIsEqualTo : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('isEqualTo')));

THIS^.testisEqualTo(
	stringToTest := "",
	expectedString := ""
);
THIS^.testisEqualTo(
	stringToTest := "not empty",
	expectedString := ""
);
THIS^.testisEqualTo(
	stringToTest := "",
	expectedString := "not empty"
);
THIS^.testisEqualTo(
	stringToTest := "not empty",
	expectedString := "not"
);
THIS^.testisEqualTo(
	stringToTest := "not empty",
	expectedString := "not empty"
);
THIS^.testisEqualTo(
	stringToTest := "{|}~",
	expectedString := "3649213469328"
);
THIS^.testisEqualTo(
	stringToTest := "1one!",
	expectedString := "1one"
);
THIS^.testisEqualTo(
	stringToTest := "1one!",
	expectedString := "1one!"
);

THIS^.testisEqualTo(
	stringToTest := "$0040$n$t$$$"$"",
	expectedString := "$n$t"
);
THIS^.testisEqualTo(
	stringToTest := "$0040$n$t$$$"$"",
	expectedString := "$0040$n$t$$$"$""
);
THIS^.testisEqualTo(
	stringToTest := "frontmiddleback",
	expectedString := "back"
);
THIS^.testisEqualTo(
	stringToTest := "frontmiddleback",
	expectedString := "frontmiddlebackfront"
);
THIS^.testisEqualTo(
	stringToTest := "backfrontmiddle",
	expectedString := "backmiddle"
);
THIS^.testisEqualTo(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y"
);
THIS^.testisEqualTo(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x"
);
THIS^.testisEqualTo(
	stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)",
	expectedString := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)"
);
THIS^.testisEqualTo(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ"
);
THIS^.testisEqualTo(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm"
);
THIS^.testisEqualTo(
	stringToTest := "ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]",
	expectedString := "ˈnæʃənəl fəˈnɛtık "
);
THIS^.testisEqualTo(
	stringToTest := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €",
	expectedString := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €"
);
THIS^.testisEqualTo(
	stringToTest := "Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,",
	expectedString := "τὴν κόψη τοῦ σπαθ"
);
THIS^.testisEqualTo(
	stringToTest := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად, რომელიც გაიმართება",
	expectedString := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად, რომელიც გაიმართება"
);
THIS^.testisEqualTo(
	stringToTest := "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в",
	expectedString := "Международную Конференцию по Unicode, которая"
);
THIS^.testisEqualTo(
	stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา ",
	expectedString := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา " 
);
THIS^.testisEqualTo(
	stringToTest := " ሰማይ አይታረስ ንጉሥ አይከሰਸ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።",
	expectedString := "አይታረስ ንጉሥ አይከሰስ። ብላ በቆመጠኝ።"
);
THIS^.testisEqualTo(
	stringToTest := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ",
	expectedString := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ"
);
THIS^.testisEqualTo(
	stringToTest := "⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞",
	expectedString := "⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋"
);
THIS^.testisEqualTo(
	stringToTest := "╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳",
	expectedString := "╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳"
);

THIS^.testisEqualToIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "UPPERCASE"
);
THIS^.testisEqualToIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "lowercase"
);
THIS^.testisEqualToIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "lowercase"
);
THIS^.testisEqualToIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "UPPERCASE"
);
THIS^.testisEqualToIgnoreCase(
	stringToTest := "UPPERCASE⌷←⍳→⍴∆∇⊃‾⍎⍕⌈",
	expectedString := "uppercase⌷←⍳→⍴∆∇⊃‾⍎⍕⌈"
);
THIS^.testisEqualToIgnoreCase(
	stringToTest := "UPPERCASE((V⍳V)=⍳⍴V)/V←,V",
	expectedString := "uppercase((V⍳V)=⍳⍴V)/V←"
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runIsNotEmpty" Id="{648785fb-ef1d-451e-b2be-615987c9b760}" FolderPath="isNotEmpty\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.IsNotEmpty``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runIsNotEmpty : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('IsNotEmpty')));

THIS^.testIsNotEmpty(
	stringToTest := ""
);
THIS^.testIsNotEmpty(
	stringToTest := "not empty"
);
THIS^.testIsNotEmpty(
	stringToTest := "{|}~"
);
THIS^.testIsNotEmpty(
	stringToTest := "3649213469328"
);
THIS^.testIsNotEmpty(
	stringToTest := "1one!"
);
THIS^.testIsNotEmpty(
	stringToTest := "$0040$n$t$$$"$""
);
THIS^.testIsNotEmpty(
	stringToTest := "$n$t"
);
THIS^.testIsNotEmpty(
	stringToTest := "frontmiddleback"
);
THIS^.testIsNotEmpty(
	stringToTest := "backfrontmiddle"
);
THIS^.testIsNotEmpty(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y"
);
THIS^.testIsNotEmpty(
	stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)",
);
THIS^.testIsNotEmpty(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
);
THIS^.testIsNotEmpty(
	stringToTest := "ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]",
);
THIS^.testIsNotEmpty(
	stringToTest := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €",
);
THIS^.testIsNotEmpty(
	stringToTest := "Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,",
);
THIS^.testIsNotEmpty(
	stringToTest := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად, რომელიც გაიმართება",
);
THIS^.testIsNotEmpty(
	stringToTest := "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в",
);
THIS^.testIsNotEmpty(
	stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา ",
);
THIS^.testIsNotEmpty(
	stringToTest := " ሰማይ አይታረስ ንጉሥ አይከሰਸ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።",
);
THIS^.testIsNotEmpty(
	stringToTest := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ",
);
THIS^.testIsNotEmpty(
	stringToTest := "⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞",
);
THIS^.testIsNotEmpty(
	stringToTest := "╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳",
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runIsNotEqualTo" Id="{ad37b676-47c2-4076-9c59-1aca11560de8}" FolderPath="isNotEqualTo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isNotEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runIsNotEqualTo : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('isNotEqualTo')));

THIS^.testisNotEqualTo(
	stringToTest := "",
	expectedString := ""
);
THIS^.testisNotEqualTo(
	stringToTest := "not empty",
	expectedString := ""
);
THIS^.testisNotEqualTo(
	stringToTest := "",
	expectedString := "not empty"
);
THIS^.testisNotEqualTo(
	stringToTest := "not empty",
	expectedString := "not"
);
THIS^.testisNotEqualTo(
	stringToTest := "not empty",
	expectedString := "not empty"
);
THIS^.testisNotEqualTo(
	stringToTest := "{|}~",
	expectedString := "3649213469328"
);
THIS^.testisNotEqualTo(
	stringToTest := "1one!",
	expectedString := "1one"
);
THIS^.testisNotEqualTo(
	stringToTest := "1one!",
	expectedString := "1one!"
);

THIS^.testisNotEqualTo(
	stringToTest := "$0040$n$t$$$"$"",
	expectedString := "$n$t"
);
THIS^.testisNotEqualTo(
	stringToTest := "$0040$n$t$$$"$"",
	expectedString := "$0040$n$t$$$"$""
);
THIS^.testisNotEqualTo(
	stringToTest := "frontmiddleback",
	expectedString := "back"
);
THIS^.testisNotEqualTo(
	stringToTest := "frontmiddleback",
	expectedString := "frontmiddlebackfront"
);
THIS^.testisNotEqualTo(
	stringToTest := "backfrontmiddle",
	expectedString := "backmiddle"
);
THIS^.testisNotEqualTo(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y"
);
THIS^.testisNotEqualTo(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x"
);
THIS^.testisNotEqualTo(
	stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)",
	expectedString := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)"
);
THIS^.testisNotEqualTo(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ"
);
THIS^.testisNotEqualTo(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm"
);
THIS^.testisNotEqualTo(
	stringToTest := "ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]",
	expectedString := "ˈnæʃənəl fəˈnɛtık "
);
THIS^.testisNotEqualTo(
	stringToTest := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €",
	expectedString := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €"
);
THIS^.testisNotEqualTo(
	stringToTest := "Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,",
	expectedString := "τὴν κόψη τοῦ σπαθ"
);
THIS^.testisNotEqualTo(
	stringToTest := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად, რომელიც გაიმართება",
	expectedString := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად, რომელიც გაიმართება"
);
THIS^.testisNotEqualTo(
	stringToTest := "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в",
	expectedString := "Международную Конференцию по Unicode, которая"
);
THIS^.testisNotEqualTo(
	stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา ",
	expectedString := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา " 
);
THIS^.testisNotEqualTo(
	stringToTest := " ሰማይ አይታረስ ንጉሥ አይከሰਸ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።",
	expectedString := "አይታረስ ንጉሥ አይከሰስ። ብላ በቆመጠኝ።"
);
THIS^.testisNotEqualTo(
	stringToTest := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ",
	expectedString := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ"
);
THIS^.testisNotEqualTo(
	stringToTest := "⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞",
	expectedString := "⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋"
);
THIS^.testisNotEqualTo(
	stringToTest := "╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳",
	expectedString := "╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳"
);

THIS^.testisNotEqualToIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "UPPERCASE"
);
THIS^.testisNotEqualToIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "lowercase"
);
THIS^.testisNotEqualToIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "lowercase"
);
THIS^.testisNotEqualToIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "UPPERCASE"
);
THIS^.testisNotEqualToIgnoreCase(
	stringToTest := "UPPERCASE⌷←⍳→⍴∆∇⊃‾⍎⍕⌈",
	expectedString := "uppercase⌷←⍳→⍴∆∇⊃‾⍎⍕⌈"
);
THIS^.testisNotEqualToIgnoreCase(
	stringToTest := "UPPERCASE((V⍳V)=⍳⍴V)/V←,V",
	expectedString := "uppercase((V⍳V)=⍳⍴V)/V←"
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runLengthIsBetween" Id="{7df5dbbe-edf6-4cf6-bac7-640b7f00079f}" FolderPath="lengthIsBetween\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsBetween``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runLengthIsBetween : BOOL
VAR
	(* for the test it"s the parameter ``stringToCheck`` *)
	stringToTest :WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* length of current string to check in bytes *)
	stringToTestByteCount		:UDINT;
	(* count of words in current string *)
	stringToTestWordCount		:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount	:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength :UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	normalizedStringToTest :WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth :DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters :UDINT := 0;
END_VAR


]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('lengthIsBetween')));


THIS^.testLengthIsBetween(
	stringToTest := "",
	maxLength := 0,
	minLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsBetween(
	stringToTest := "",
	maxLength := 0,
	minLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsBetween(
	stringToTest := "",
	maxLength := 0,
	minLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := "",
	maxLength := 0,
	minLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := "not empty",
	maxLength := 9,
	minLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := "not empty",
	maxLength := 13,
	minLength := 10,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := "not empty",
	maxLength := 18,
	minLength := 18,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsBetween(
	stringToTest := "not empty",
	maxLength := 26,
	minLength := 20,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsBetween(
	stringToTest := "1one!",
	maxLength := 5,
	minLength := 4,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := "1one!",
	maxLength := 5,
	minLength := 4,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH
);
THIS^.testLengthIsBetween(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	maxLength := 255,
	minLength := 255,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	maxLength := 510,
	minLength := 510,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsBetween(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	maxLength := 254,
	minLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	maxLength := 509,
	minLength := 509,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);

stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestByteCount,
	minLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount,
	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestByteCount - 1,
	minLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := TO_UDINT(stringToTestWidth),
	minLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestVisibleCharacters,
	minLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);

stringToTest := "ÄЗарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestByteCount,
	minLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount,
	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount + 1,
	minLength := stringToTestCodePointCount - 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := TO_UDINT(stringToTestWidth),
	minLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
); 
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestVisibleCharacters,
	minLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount,
	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount,
	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount,
	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);

stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่  สิบสองกษัตริย์ก่อนหน้าแล ";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestByteCount,
  	minLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
 	maxLength := stringToTestCodePointCount,
 	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := TO_UDINT(stringToTestWidth),
  	minLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestVisibleCharacters,
  	minLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);

stringToTest := "🧌🦤🏭💽🧧🪷👨‍💻👩‍👩‍👧‍👦";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestByteCount,
  	minLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount + 1,
  	minLength := stringToTestCodePointCount - 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := TO_UDINT(stringToTestWidth),
  	minLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestVisibleCharacters,
  	minLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runLengthIsExact" Id="{97e68c29-7203-4575-88c2-94a26b970811}" FolderPath="lengthIsExact\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsExact``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runLengthIsExact : BOOL
VAR
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest :WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* length of current string to check in bytes *)
	stringToTestByteCount		:UDINT;
	(* count of words in current string *)
	stringToTestWordCount		:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount	:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength :UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	normalizedStringToTest :WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth :DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters :UDINT := 0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('lengthIsExact')));

THIS^.testLengthIsExact(
	stringToTest := "",
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := "",
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := "",
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := "",
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := "not empty",
	expectedLength := 9,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := "not empty",
	expectedLength := 18,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := "not empty",
	expectedLength := 8,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := "not empty",
	expectedLength := 19,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := "1one!",
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := "1one!",
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH
);
THIS^.testLengthIsExact(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 510,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 511,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 255,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 254,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);

stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount - 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);

stringToTest := "ÄЗарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
); 
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);

stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่  สิบสองกษัตริย์ก่อนหน้าแล ";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
 	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
 	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);

stringToTest := "🧌🦤🏭💽🧧🪷👨‍💻👩‍👩‍👧‍👦";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runLengthIsMax" Id="{ac9eea82-c19b-48a2-9a64-e719aeb8b611}" FolderPath="lengthIsMax\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsMax``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runLengthIsMax : BOOL
VAR
	(* for the test it"s the parameter ``stringToCheck`` *)
	stringToTest :WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* length of current string to check in bytes *)
	stringToTestByteCount		:UDINT;
	(* count of words in current string *)
	stringToTestWordCount		:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount	:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength :UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	normalizedStringToTest :WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth :DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters :UDINT := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('lengthIsMax')));

THIS^.testLengthIsMax(
	stringToTest := "",
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := "",
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := "",
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := "",
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := "not empty",
	expectedLength := 9,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := "not empty",
	expectedLength := 18,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := "not empty",
	expectedLength := 8,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := "not empty",
	expectedLength := 19,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := "1one!",
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := "1one!",
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH
);
THIS^.testLengthIsMax(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 510,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 511,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 255,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 254,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);

stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount - 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);

stringToTest := "ÄЗарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
); 
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);

stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่  สิบสองกษัตริย์ก่อนหน้าแล ";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
 	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
 	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);

stringToTest := "🧌🦤🏭💽🧧🪷👨‍💻👩‍👩‍👧‍👦";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runLengthIsMin" Id="{78ea44cb-891d-4a3a-b1e6-84b3a1f916af}" FolderPath="lengthIsMin\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsMin``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runLengthIsMin : BOOL
VAR
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest :WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* length of current string to check in bytes *)
	stringToTestByteCount		:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount	:UDINT;
	(* count of words in current string *)
	stringToTestWordCount		:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength :UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	normalizedStringToTest :WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth :DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters :UDINT := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('lengthIsMin')));

THIS^.testLengthIsMin(
	stringToTest := "",
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := "",
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := "",
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := "",
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := "not empty",
	expectedLength := 9,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := "not empty",
	expectedLength := 18,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := "not empty",
	expectedLength := 8,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := "not empty",
	expectedLength := 19,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := "1one!",
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := "1one!",
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH
);
THIS^.testLengthIsMin(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 510,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 511,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 255,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedLength := 254,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);

stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount - 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);

stringToTest := "ÄЗарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
); 
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);

stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่  สิบสองกษัตริย์ก่อนหน้าแล ";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
 	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
 	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);

stringToTest := "🧌🦤🏭💽🧧🪷👨‍💻👩‍👩‍👧‍👦";
CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runStartsWith" Id="{dad9df31-d6f0-4690-811e-cc65042bc71e}" FolderPath="startsWith\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.startsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runStartsWith : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('startsWith')));

THIS^.testStartsWith(
	stringToTest := "",
	expectedString := ""
);
THIS^.testStartsWith(
	stringToTest := "not empty",
	expectedString := ""
);
THIS^.testStartsWith(
	stringToTest := "",
	expectedString := "not empty"
);
THIS^.testStartsWith(
	stringToTest := "not empty",
	expectedString := "not empty"
);
THIS^.testStartsWith(
	stringToTest := "{|}~",
	expectedString := "3649213469328"
);
THIS^.testStartsWith(
	stringToTest := "1one!",
	expectedString := "1"
);
THIS^.testStartsWith(
	stringToTest := "1one!",
	expectedString := "one"
);
THIS^.testStartsWith(
	stringToTest := "1one!",
	expectedString := "!"
);
THIS^.testStartsWith(
	stringToTest := "$0040$n$t$$$"$"",
	expectedString := "$n$t"
);
THIS^.testStartsWith(
	stringToTest := "$n$t$0040$$$"$"",
	expectedString := "$n$t"
);
THIS^.testStartsWith(
	stringToTest := "frontmiddleback",
	expectedString := "front"
);
THIS^.testStartsWith(
	stringToTest := "frontmiddleback",
	expectedString := "frontmiddlebackfront"
);
THIS^.testStartsWith(
	stringToTest := "backfrontmiddle",
	expectedString := "backmiddle"
);
THIS^.testStartsWith(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y"
);
THIS^.testStartsWith(
	stringToTest := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y",
	expectedString := "J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x"
);
THIS^.testStartsWith(
	stringToTest := "∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)",
	expectedString := "∮ E⋅da = Q,  n → ∞"
);
THIS^.testStartsWith(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ⊂ ℚ ⊂ ℝ ⊂ ℂ"
);
THIS^.testStartsWith(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, R = 4.7 kΩ, ⌀ 200 mm"
);
THIS^.testStartsWith(
	stringToTest := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm",
	expectedString := "ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ⊥"
);
THIS^.testStartsWith(
	stringToTest := "ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]ˈnæʃənəl fəˈnɛtık ",
	expectedString := "ði ıntəˈnæʃənəl fəˈnɛtık"
);
THIS^.testStartsWith(
	stringToTest := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €",
	expectedString := "‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €"
);
THIS^.testStartsWith(
	stringToTest := "Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,",
	expectedString := "τὴν κόψη τοῦ σπαθ"
);
THIS^.testStartsWith(
	stringToTest := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად, რომელიც გაიმართება",
	expectedString := "გთხოვთ ახლავე გაიაროთ რეგისტრაცია"
);
THIS^.testStartsWith(
	stringToTest := "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в",
	expectedString := "Международную Конференцию по Unicode, которая"
);
THIS^.testStartsWith(
	stringToTest := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา ",
	expectedString := "๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช " 
);
THIS^.testStartsWith(
	stringToTest := " ሰማይ አይታረስ ንጉሥ አይከሰስ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።",
	expectedString := "አይታረስ ንጉሥ አይከሰስ። በቆመጠኝ።"
);
THIS^.testStartsWith(
	stringToTest := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ",
	expectedString := " ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ"
);
THIS^.testStartsWith(
	stringToTest := "⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞",
	expectedString := "⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙"
);
THIS^.testStartsWith(
	stringToTest := "╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳",
	expectedString := "╔══╦══╗  ┌──┬──┐"
);

THIS^.testStartsWithIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "UPPER"
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "lower"
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := "UPPERCASE",
	expectedString := "upper"
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := "lowercase",
	expectedString := "LOWER"
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := "lower",
	expectedString := "UPPER"
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := "⌷←⍳→⍴∆∇⊃‾⍎⍕⌈UPPERCASE",
	expectedString := "⌷←⍳→⍴∆∇⊃‾⍎⍕⌈upper"
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := "⌷←⍳→⍴∆∇⊃‾⍎⍕⌈UPPERCASE",
	expectedString := "⌷←⍳→⍴∆∇⊃‾⍎⍕⌈|upper"
);

THIS^.testStartsWithTrim(
	stringToTest := "$tfrontmiddleback",
	expectedString := "front"
);
THIS^.testStartsWithTrim(
	stringToTest := "frontmiddleback",
	expectedString := "$tfront"
);
THIS^.testStartsWithTrim(
	stringToTest := "$0020frontmiddleback",
	expectedString := "front"
);
THIS^.testStartsWithTrim(
	stringToTest := "frontmiddleback",
	expectedString := "$0020front"
);
THIS^.testStartsWithTrim(
	stringToTest := "$t$n$r$p$lfrontmiddleback",
	expectedString := "$0020$r$t$n$l$pfront"
);
THIS^.testStartsWithTrim(
	stringToTest := "$t$n$r$p$lfrontmiddleback",
	expectedString := "$0020$t$n$r$p$lfront"
);
THIS^.testStartsWithTrim(
	stringToTest := "$t$n$r$p$l⌷←⍳→⍴∆∇⊃‾⍎⍕⌈frontmiddleback$t$n$r$p$l",
	expectedString := "⌷←⍳→⍴∆∇⊃‾⍎⍕⌈front"
);
THIS^.testStartsWithTrim(
	stringToTest := "$t$n$r$p$l⌷←⍳→⍴∆∇⊃‾⍎⍕⌈frontmiddleback$t$n$r$p$l",
	expectedString := "⌷←⍳→⍴∆∇⊃‾⍎⍕front⌈"
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testContains" Id="{ba47cdc6-f579-482b-b616-203aa6808048}" FolderPath="contains\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.contains``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testContains : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest 					:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString					:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(expectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(stringToTest),
			ADR(expectedString),
		) = 0
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be FALSE'
);
Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.contains(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedStringToTest),
			ADR(normalizedExpectedString),
		) = 0
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.contains(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testContainsIgnoreCase" Id="{6123c696-9991-4768-9668-a96bcded8021}" FolderPath="contains\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.contains``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testContainsIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(upperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(upperStringToTest),
			ADR(upperExpectedString),
		) = 0
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.contains(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperExpectedString));


CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedUpperStringToTest),
			ADR(normalizedUpperExpectedString),
		) = 0
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.contains(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testContainsNo" Id="{c07595c5-dc4e-42fa-805c-97254b15e321}" FolderPath="containsNo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.containsNo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testContainsNo : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(expectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(stringToTest),
			ADR(expectedString),
		) > 0
	) OR (
		expectedCharacterCount = 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.containsNo(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedStringToTest),
			ADR(normalizedExpectedString),
		) > 0
	) OR (
		expectedCharacterCount = 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.containsNo(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testContainsNoIgnoreCase" Id="{c7984f1d-179a-4476-99bf-e27e80a838dd}" FolderPath="containsNo\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.containsNo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testContainsNoIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(upperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(upperStringToTest),
			ADR(upperExpectedString),
		) > 0
	) OR (
		expectedCharacterCount = 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.containsNo(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperExpectedString));


CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedUpperStringToTest),
			ADR(normalizedUpperExpectedString),
		) > 0
	) OR (
		expectedCharacterCount = 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.containsNo(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testEndsWith" Id="{05636121-ea00-477e-bc2a-a615858e8e88}" FolderPath="endsWith\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.endsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testEndsWith : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains the rigth side of ``stringToCheck`` *)
	rigthOfStringToCheck			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(expectedString),
	characterCount => expectedCharacterCount
);
rigthOfStringToCheck := WRIGHT(stringToTest, TO_INT(expectedCharacterCount));
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(rigthOfStringToCheck),
			ADR(expectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' end is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' end is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := FALSE,
	trim := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
rigthOfStringToCheck := WRIGHT(normalizedStringToTest, TO_INT(expectedCharacterCount));
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(rigthOfStringToCheck),
			ADR(normalizedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := FALSE,
	trim		:= FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testEndsWithIgnoreCase" Id="{0f1481e9-09cb-43a3-9147-6031a00465a8}" FolderPath="endsWith\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.endsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testEndsWithIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains the rigth side of ``stringToCheck`` *)
	rigthOfStringToCheck			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(upperExpectedString),
	characterCount => expectedCharacterCount
);
rigthOfStringToCheck := WRIGHT(upperStringToTest, TO_INT(expectedCharacterCount));
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(rigthOfStringToCheck),
			ADR(upperExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);
message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' end is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' end is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := TRUE,
	trim := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
THIS^.assertorContainer.resetAssertor();

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperExpectedString));


CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
rigthOfStringToCheck := WRIGHT(normalizedUpperStringToTest, TO_INT(expectedCharacterCount));
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(rigthOfStringToCheck),
			ADR(normalizedUpperExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := TRUE,
	trim		:= FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testEndsWithTrim" Id="{b07a410f-ab95-4928-8e90-fbb0b160326f}" FolderPath="endsWith\trim\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.endsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testEndsWithTrim : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest 	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``end`` *)
	expectedString :WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains trimed ´´stringToTest´´ *)
	trimedStringToTest				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains trimed ´´expectedString´´ *)
	trimedExpectedString			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString	 		:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* right side of ``stringToCheck`` *)
	rigthOfStringToCheck			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains stringToTest in normalized form trimed *)
	normalizedTrimedStringToTest	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form trimed *)
	normalizedTrimedExpectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

trimedStringToTest := stringToTest;
trimedExpectedString := expectedString;

// trim the right of both strings
CNM_UnicodeUtilities.TrimRightUtf16String(ADR(trimedStringToTest));
CNM_UnicodeUtilities.TrimRightUtf16String(ADR(trimedExpectedString));

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(trimedExpectedString),
	characterCount => expectedCharacterCount
);
rigthOfStringToCheck := WRIGHT(trimedStringToTest, TO_INT(expectedCharacterCount));
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(rigthOfStringToCheck),
			ADR(trimedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' end is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' end is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := FALSE,
	trim := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
THIS^.assertorContainer.resetAssertor();

normalizedTrimedStringToTest := normalizedStringToTest;
normalizedTrimedExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.TrimRightUtf16String(ADR(normalizedTrimedStringToTest));
CNM_UnicodeUtilities.TrimRightUtf16String(ADR(normalizedTrimedExpectedString));

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedTrimedExpectedString),
	characterCount => expectedCharacterCount
);
rigthOfStringToCheck := WRIGHT(normalizedTrimedStringToTest, TO_INT(expectedCharacterCount));
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(rigthOfStringToCheck),
			ADR(normalizedTrimedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := FALSE,
	trim		:= TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsEmpty" Id="{8184618f-b467-418c-9355-fedd32334ca7}" FolderPath="isEmpty\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isEmpty``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testisEmpty : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest :WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(stringToTest),
	characterCount => stringToTestCharacterCount
);
assertionIsWrong :=  stringToTestCharacterCount > 0;

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
);


THIS^.assertorContainer.assertor.assert.strings.unicode.isEmpty(
	stringToCheck := stringToTest,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsEqualTo" Id="{4fb08250-1bb4-4e18-bd90-3758821238e2}" FolderPath="isEqualTo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testIsEqualTo : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(stringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(expectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount <> expectedCharacterCount
	) OR (
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(stringToTest),
			ADR(expectedString),
		) <> 1
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' expected is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' expected is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);
THIS^.assertorContainer.resetAssertor();

THIS^.assertorContainer.assertor.assert.strings.unicode.isEqualTo(
	stringToCheck := stringToTest,
	expected := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount <> expectedCharacterCount
	) OR (
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedStringToTest),
			ADR(normalizedExpectedString),
		) <> 1
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.isEqualTo(
	stringToCheck := stringToTest,
	expected := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsEqualToIgnoreCase" Id="{821d13a1-5594-40f3-bd6f-80bd20a2f133}" FolderPath="isEqualTo\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testIsEqualToIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(upperStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(upperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount <> expectedCharacterCount
	) OR (
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(upperStringToTest),
			ADR(upperExpectedString),
		) <> 1
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' expected is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' expected is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);
THIS^.assertorContainer.resetAssertor();

THIS^.assertorContainer.assertor.assert.strings.unicode.isEqualTo(
	stringToCheck := stringToTest,
	expected := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperExpectedString));


CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedUpperStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount <> expectedCharacterCount
	) OR (
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedUpperStringToTest),
			ADR(normalizedUpperExpectedString),
		) <> 1
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.isEqualTo(
	stringToCheck := stringToTest,
	expected := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsNotEmpty" Id="{bd8f6a5d-6533-4fe6-be95-ad80f7c0ca58}" FolderPath="isNotEmpty\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isNotEmpty``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testIsNotEmpty : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest :WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(stringToTest),
	characterCount => stringToTestCharacterCount
);
assertionIsWrong :=  stringToTestCharacterCount = 0;

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
);


THIS^.assertorContainer.assertor.assert.strings.unicode.isNotEmpty(
	stringToCheck := stringToTest,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsNotEqualTo" Id="{7ccbb3ab-d252-493e-b99f-3671314b044e}" FolderPath="isNotEqualTo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isNotEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testIsNotEqualTo : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(stringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(expectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount = expectedCharacterCount
	) AND (
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(stringToTest),
			ADR(expectedString),
		) = 1
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' unexpected is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' unexpected is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF


messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.isNotEqualTo(
	stringToCheck := stringToTest,
	unexpected := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount = expectedCharacterCount
	) AND (
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedStringToTest),
			ADR(normalizedExpectedString),
		) = 1
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.isNotEqualTo(
	stringToCheck := stringToTest,
	unexpected := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsNotEqualToIgnoreCase" Id="{5876a0bd-4ad0-4edc-ab79-7285bbc8d161}" FolderPath="isNotEqualTo\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isNotEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testIsNotEqualToIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(upperStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(upperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount = expectedCharacterCount
	) AND (
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(upperStringToTest),
			ADR(upperExpectedString),
		) = 1
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' unexpected is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' unexpected is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);
THIS^.assertorContainer.resetAssertor();

THIS^.assertorContainer.assertor.assert.strings.unicode.isNotEqualTo(
	stringToCheck := stringToTest,
	unexpected := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperExpectedString));


CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedUpperStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount = expectedCharacterCount
	) AND (
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedUpperStringToTest),
			ADR(normalizedUpperExpectedString),
		) = 1
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.isNotEqualTo(
	stringToCheck := stringToTest,
	unexpected := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testLengthIsBetween" Id="{52d3af52-66cb-42f7-962e-35df060fc180}" FolderPath="lengthIsBetween\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsBetween``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testLengthIsBetween : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``maxLength`` *)
	maxLength 				:UDINT;
	(* for the test it's the parameter ``minLength`` *)
	minLength 				:UDINT;
	(* UnicodeStringLengthUnit the input is tested for *)
	stringLengthUnit		:CNM_AssertionInterfaces.UnicodeStringLengthUnit;
	(* contains ``stringToTest`` in only ascii charachters for test output *)
	stringToTestPrintable	:Tc2_System.T_MaxString := '';
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds string with current ´´stringLengthUnit´´ for the test message*)
	currentStringLengthUnit			:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* length of current string to check in bytes *)
	stringToTestByteCount			:UDINT;
	(* count of words in current string *)
	stringToTestWordCount			:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount		:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength 				:UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	normalizedStringToTest 			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth 				:DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters	:UDINT;
	(*string in UTF32*)
	utf32String						:ARRAY [0..Tc2_System.Global_Variables.MAX_STRING_LENGTH]  OF CNM_UnicodeUtilities.UnicodeCodePoint;
	(* utf32 code point count *)
	utf32CodePointCount 			:UDINT;
	(* bytes in utf8 string *)
	utf8ByteCount 					:UDINT;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;

CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;

CNM_UnicodeUtilities.GetCodepointsFromUtf16String(
	utf16StringAddress := ADR(stringToTest),
	utf16StringWordCount := stringToTestWordCount,
	codepointBuffer :=ADR(utf32String),
	bufferSize := SIZEOF(utf32String),
	codePointCount => utf32CodePointCount
);

CNM_UnicodeUtilities.GetUtf8StringFromCodepoints(
	addressOfCodePoints := ADR(utf32String),
	codePointCount := utf32CodePointCount,
	utf8StringBuffer := ADR(stringToTestAsString),
	bufferSize := MAX_STRING_LENGTH + 1,
	utf8StringByteCount => utf8ByteCount
);

IF ( Tc2_Standard.LEN(stringToTestPrintable) <> 0 ) THEN
	stringToTestAsString := stringToTestPrintable;
END_IF


CASE stringLengthUnit OF
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES:
	currentStringLengthUnit := 'BYTES';
	
	assertionIsWrong := stringToTestByteCount < minLength OR stringToTestByteCount > maxLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS:
	currentStringLengthUnit := 'CHARACTERS';
	
	assertionIsWrong := ((
			stringToTestCodePointCount < minLength
		) OR (
			stringToTestCodePointCount > maxLength
		)
	);
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD:
	currentStringLengthUnit := 'NFD';
	
	CNM_UnicodeUtilities.NormalizeUtf16String(
		utf16StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf16StringLength(
		utf16StringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := ((
			stringToTestCodePointCount < minLength
		) OR (
			stringToTestCodePointCount > maxLength
		)
	);
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC:
	currentStringLengthUnit := 'NFC';
	
	CNM_UnicodeUtilities.NormalizeUtf16String(
		utf16StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf16StringLength(
		utf16StringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := ((
			stringToTestCodePointCount < minLength
		) OR (
			stringToTestCodePointCount > maxLength
		)
	);
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS:
	currentStringLengthUnit := 'VISIBLE_CHARACTERS';
	
	assertionIsWrong := ((
			stringToTestVisibleCharacters < minLength
		) OR (
			stringToTestVisibleCharacters > maxLength
		)
	);
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH:
	currentStringLengthUnit := 'WIDTH';
	
	assertionIsWrong := ((
			TO_UDINT(stringToTestWidth) < minLength
		) OR (
			TO_UDINT(stringToTestWidth) > maxLength
		)
	);
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testLengthIsExact" Id="{f1edfbd3-764e-4d83-a410-17b5d12532d8}" FolderPath="lengthIsExact\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsExact``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testLengthIsExact : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest 			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``expectedLength`` *)
	expectedLength			:UDINT;
	(* UnicodeStringLengthUnit the input is tested for *)
	stringLengthUnit		:CNM_AssertionInterfaces.UnicodeStringLengthUnit;
	(* contains ``stringToTest`` in only ascii charachters for test output *)
	stringToTestPrintable	:Tc2_System.T_MaxString := '';
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds string with current ´´stringLengthUnit´´ for the test message*)
	currentStringLengthUnit 		:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* length of current string to check in bytes *)
	stringToTestByteCount			:UDINT;
	(* count of words in current string *)
	stringToTestWordCount			:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount		:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength 				:UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	normalizedStringToTest 			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth 				:DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters	:UDINT := 0;
	(*string in UTF32*)
	utf32String						:ARRAY [0..Tc2_System.Global_Variables.MAX_STRING_LENGTH]  OF CNM_UnicodeUtilities.UnicodeCodePoint;
	(* utf32 code point count *)
	utf32CodePointCount 			:UDINT;
	(* bytes in utf8 string *)
	utf8ByteCount 					:UDINT;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;

CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;

CNM_UnicodeUtilities.GetCodepointsFromUtf16String(
	utf16StringAddress := ADR(stringToTest),
	utf16StringWordCount := stringToTestWordCount,
	codepointBuffer :=ADR(utf32String),
	bufferSize := SIZEOF(utf32String),
	codePointCount => utf32CodePointCount
);

CNM_UnicodeUtilities.GetUtf8StringFromCodepoints(
	addressOfCodePoints := ADR(utf32String),
	codePointCount := utf32CodePointCount,
	utf8StringBuffer := ADR(stringToTestAsString),
	bufferSize := MAX_STRING_LENGTH + 1,
	utf8StringByteCount => utf8ByteCount
);

IF ( Tc2_Standard.LEN(stringToTestPrintable) <> 0 ) THEN
	stringToTestAsString := stringToTestPrintable;
END_IF

CASE stringLengthUnit OF
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES:
	currentStringLengthUnit := 'BYTES';
	
	assertionIsWrong := stringToTestByteCount <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS:
	currentStringLengthUnit := 'CHARACTERS';
	
	assertionIsWrong := stringToTestCodePointCount <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD:
	currentStringLengthUnit := 'NFD';
	
	CNM_UnicodeUtilities.NormalizeUtf16String(
		utf16StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf16StringLength(
		utf16StringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC:
	currentStringLengthUnit := 'NFC';
	
	CNM_UnicodeUtilities.NormalizeUtf16String(
		utf16StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf16StringLength(
		utf16StringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS:	
	currentStringLengthUnit := 'VISIBLE_CHARACTERS';
	
	assertionIsWrong := stringToTestVisibleCharacters <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH:	
	currentStringLengthUnit := 'WIDTH';
	
	assertionIsWrong := TO_UDINT(stringToTestWidth) <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testLengthIsMax" Id="{57d6f877-2829-4791-a542-22e450d3c4cf}" FolderPath="lengthIsMax\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsMax``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testLengthIsMax : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest 			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``maxLength`` *)
	expectedLength 			:UDINT;
	(* UnicodeStringLengthUnit the input is tested for *)
	stringLengthUnit		:CNM_AssertionInterfaces.UnicodeStringLengthUnit;
	(* contains ``stringToTest`` in only ascii charachters for test output *)
	stringToTestPrintable	:Tc2_System.T_MaxString := '';
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong					:BOOL;
	(* contains the format string for the test message *)
	message								:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 				:Tc2_System.T_MaxString;
	(* holds string with current ´´stringLengthUnit´´ for the test message*)
	currentStringLengthUnit 			:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder				:Tc2_Utilities.FB_FormatString;
	(* length of current string to check in bytes *)
	stringToTestByteCount				:UDINT;
	(* count of words in current string *)
	stringToTestWordCount				:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount			:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength 					:UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	normalizedStringToTest 				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth 					:DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters 		:UDINT := 0;
	(*string in UTF32*)
	utf32String							:ARRAY [0..Tc2_System.Global_Variables.MAX_STRING_LENGTH]  OF CNM_UnicodeUtilities.UnicodeCodePoint;
	(* utf32 code point count *)
	utf32CodePointCount 				:UDINT;
	(* bytes in utf8 string *)
	utf8ByteCount 						:UDINT;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;

CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;

CNM_UnicodeUtilities.GetCodepointsFromUtf16String(
	utf16StringAddress := ADR(stringToTest),
	utf16StringWordCount := stringToTestWordCount,
	codepointBuffer :=ADR(utf32String),
	bufferSize := SIZEOF(utf32String),
	codePointCount => utf32CodePointCount
);

CNM_UnicodeUtilities.GetUtf8StringFromCodepoints(
	addressOfCodePoints := ADR(utf32String),
	codePointCount := utf32CodePointCount,
	utf8StringBuffer := ADR(stringToTestAsString),
	bufferSize := MAX_STRING_LENGTH + 1,
	utf8StringByteCount => utf8ByteCount
);

IF ( Tc2_Standard.LEN(stringToTestPrintable) <> 0 ) THEN
	stringToTestAsString := stringToTestPrintable;
END_IF


CASE stringLengthUnit OF
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES:
	currentStringLengthUnit := 'BYTES';
	
	assertionIsWrong := stringToTestByteCount > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS:	
	currentStringLengthUnit := 'CHARACTERS';
	
	assertionIsWrong := stringToTestCodePointCount > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD:	
	currentStringLengthUnit := 'NFD';
	
	CNM_UnicodeUtilities.NormalizeUtf16String(
		utf16StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf16StringLength(
		utf16StringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC:	
	currentStringLengthUnit := 'NFC';
	
	CNM_UnicodeUtilities.NormalizeUtf16String(
		utf16StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf16StringLength(
		utf16StringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS:	
	currentStringLengthUnit := 'VISIBLE_CHARACTERS';
	
	assertionIsWrong := stringToTestVisibleCharacters > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH:	
	currentStringLengthUnit := 'WIDTH';
	
	assertionIsWrong := TO_UDINT(stringToTestWidth) > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testLengthIsMin" Id="{4985ee46-e6ec-45fb-aec4-0c0cf5c7afe7}" FolderPath="lengthIsMin\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsMin``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testLengthIsMin : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest 			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``minLength`` *)
	expectedLength 			:UDINT;
	(* UnicodeStringLengthUnit the input is tested for *)
	stringLengthUnit		:CNM_AssertionInterfaces.UnicodeStringLengthUnit;
	(* contains ``stringToTest`` in only ascii charachters for test output *)
	stringToTestPrintable	:Tc2_System.T_MaxString := '';
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds string with current ´´stringLengthUnit´´ for the test message*)
	currentStringLengthUnit 		:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* length of current string to check in bytes *)
	stringToTestByteCount			:UDINT;
	(* count of words in current string *)
	stringToTestWordCount			:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount		:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength 				:UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	normalizedStringToTest 			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth 				:DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters 	:UDINT := 0;
	(*string in UTF32*)
	utf32String						:ARRAY [0..Tc2_System.Global_Variables.MAX_STRING_LENGTH]  OF CNM_UnicodeUtilities.UnicodeCodePoint;
	(* utf32 code point count *)
	utf32CodePointCount 			:UDINT;
	(* bytes in utf8 string *)
	utf8ByteCount 					:UDINT;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;

CNM_UnicodeUtilities.GetUtf16StringLength(ADR(stringToTest), wordCount => stringToTestWordCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf16StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
stringToTestByteCount := stringToTestWordCount * 2;

CNM_UnicodeUtilities.GetCodepointsFromUtf16String(
	utf16StringAddress := ADR(stringToTest),
	utf16StringWordCount := stringToTestWordCount,
	codepointBuffer :=ADR(utf32String),
	bufferSize := SIZEOF(utf32String),
	codePointCount => utf32CodePointCount
);

CNM_UnicodeUtilities.GetUtf8StringFromCodepoints(
	addressOfCodePoints := ADR(utf32String),
	codePointCount := utf32CodePointCount,
	utf8StringBuffer := ADR(stringToTestAsString),
	bufferSize := MAX_STRING_LENGTH + 1,
	utf8StringByteCount => utf8ByteCount
);

IF ( Tc2_Standard.LEN(stringToTestPrintable) <> 0 ) THEN
	stringToTestAsString := stringToTestPrintable;
END_IF


CASE stringLengthUnit OF
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES:	
	currentStringLengthUnit := 'BYTES';
	
	assertionIsWrong := stringToTestByteCount < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS:	
	currentStringLengthUnit := 'CHARACTERS';
	
	assertionIsWrong := stringToTestCodePointCount < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD:	
	currentStringLengthUnit := 'NFD';
	
	CNM_UnicodeUtilities.NormalizeUtf16String(
		utf16StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf16StringLength(
		utf16StringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC:	
	currentStringLengthUnit := 'NFC';
	
	CNM_UnicodeUtilities.NormalizeUtf16String(
		utf16StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf16StringLength(
		utf16StringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS:	
	currentStringLengthUnit := 'VISIBLE_CHARACTERS';
	
	assertionIsWrong := stringToTestVisibleCharacters < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH:	
	currentStringLengthUnit := 'WIDTH';
	
	assertionIsWrong := TO_UDINT(stringToTestWidth) < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_WSTRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testStartsWith" Id="{205c2676-edd1-4432-b950-c380aadc52d2}" FolderPath="startsWith\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.startsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testStartsWith : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(expectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(stringToTest),
			ADR(expectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' start is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' start is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := FALSE,
	trim := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
// no trim for ``start`` expected
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedStringToTest),
			ADR(normalizedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := FALSE,
	trim		:= FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testStartsWithIgnoreCase" Id="{b1448d34-0366-4af3-a23c-6417a5b93c8c}" FolderPath="startsWith\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.startsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testStartsWithIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(upperExpectedString),
	characterCount => expectedCharacterCount
);	
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(upperStringToTest),
			ADR(upperExpectedString)
		) <> 1 
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' start is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' start is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := TRUE,
	trim := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.GetUpperCaseUtf16(ADR(normalizedUpperExpectedString));


CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedUpperStringToTest),
			ADR(normalizedUpperExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := TRUE,
	trim		:= FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="testStartsWithTrim" Id="{182bc8c5-e0b6-4e98-9281-e3f39d220c95}" FolderPath="startsWith\trim\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.startsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testStartsWithTrim : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	stringToTest  	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* for the test it's the parameter ``searchString`` *)
	expectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ trimed *)
	trimedStringToTest				:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains ´´expectedString´´ trimed *)
	trimedExpectedString			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains stringToTest in normalized form trimed *)
	normalizedTrimedStringToTest	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* contains expectedString in normalized form trimed *)
	normalizedTrimedExpectedString	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:WSTRING(Tc2_System.MAX_STRING_LENGTH);
	(* hold stringToCheck before assertion *)
	expectedStringBeforeAssertion	:WSTRING(Tc2_System.MAX_STRING_LENGTH);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

trimedStringToTest := stringToTest;
trimedExpectedString := expectedString;

// trim the left of both strings
CNM_UnicodeUtilities.TrimLeftUtf16String(ADR(trimedStringToTest));
CNM_UnicodeUtilities.TrimLeftUtf16String(ADR(trimedExpectedString));

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(trimedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(trimedStringToTest),
			ADR(trimedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' start is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' start is $'%s$' assertion must be FALSE'
);

Tc2_Utilities.WSTRING_TO_STRING2(ADR(stringToTestAsString), ADR(stringToTest), SIZEOF(stringToTestAsString));
Tc2_Utilities.WSTRING_TO_STRING2(ADR(expectedStringAsString), ADR(expectedString), SIZEOF(expectedStringAsString));

IF (
		Tc2_Standard.WLEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.WLEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := FALSE,
	trim := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf16String(
	utf16StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH * 2 + 2,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedTrimedStringToTest := normalizedStringToTest;
normalizedTrimedExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.TrimLeftUtf16String(ADR(normalizedTrimedStringToTest));
CNM_UnicodeUtilities.TrimLeftUtf16String(ADR(normalizedTrimedExpectedString));

CNM_UnicodeUtilities.GetUtf16StringLength(
	utf16StringAddress := ADR(normalizedTrimedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf16String(
			ADR(normalizedTrimedStringToTest),
			ADR(normalizedTrimedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := FALSE,
	trim		:= TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_WSTRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="UnicodeUtf16StringAssertionTests">
      <LineId Id="1" Count="11" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.getTestNameFor">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runContains">
      <LineId Id="1" Count="4" />
      <LineId Id="153" Count="0" />
      <LineId Id="7" Count="27" />
      <LineId Id="150" Count="0" />
      <LineId Id="36" Count="108" />
      <LineId Id="147" Count="2" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runContainsNo">
      <LineId Id="1" Count="144" />
      <LineId Id="147" Count="2" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runEndsWith">
      <LineId Id="1" Count="181" />
      <LineId Id="184" Count="2" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runIsEmpty">
      <LineId Id="1" Count="69" />
      <LineId Id="72" Count="1" />
      <LineId Id="75" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runIsEqualTo">
      <LineId Id="1" Count="142" />
      <LineId Id="145" Count="2" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runIsNotEmpty">
      <LineId Id="1" Count="69" />
      <LineId Id="72" Count="1" />
      <LineId Id="75" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runIsNotEqualTo">
      <LineId Id="1" Count="145" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runLengthIsBetween">
      <LineId Id="1" Count="6" />
      <LineId Id="353" Count="0" />
      <LineId Id="8" Count="4" />
      <LineId Id="354" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="356" Count="10" />
      <LineId Id="355" Count="0" />
      <LineId Id="14" Count="3" />
      <LineId Id="367" Count="0" />
      <LineId Id="18" Count="4" />
      <LineId Id="368" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="376" Count="4" />
      <LineId Id="375" Count="0" />
      <LineId Id="370" Count="4" />
      <LineId Id="369" Count="0" />
      <LineId Id="34" Count="2" />
      <LineId Id="381" Count="1" />
      <LineId Id="38" Count="4" />
      <LineId Id="383" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="54" Count="3" />
      <LineId Id="384" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="386" Count="4" />
      <LineId Id="385" Count="0" />
      <LineId Id="59" Count="2" />
      <LineId Id="391" Count="0" />
      <LineId Id="397" Count="0" />
      <LineId Id="63" Count="4" />
      <LineId Id="398" Count="0" />
      <LineId Id="68" Count="2" />
      <LineId Id="304" Count="1" />
      <LineId Id="72" Count="4" />
      <LineId Id="399" Count="0" />
      <LineId Id="77" Count="5" />
      <LineId Id="400" Count="0" />
      <LineId Id="83" Count="5" />
      <LineId Id="401" Count="0" />
      <LineId Id="89" Count="5" />
      <LineId Id="402" Count="0" />
      <LineId Id="95" Count="5" />
      <LineId Id="403" Count="0" />
      <LineId Id="101" Count="3" />
      <LineId Id="306" Count="1" />
      <LineId Id="106" Count="4" />
      <LineId Id="404" Count="0" />
      <LineId Id="111" Count="5" />
      <LineId Id="405" Count="0" />
      <LineId Id="117" Count="5" />
      <LineId Id="406" Count="0" />
      <LineId Id="123" Count="5" />
      <LineId Id="407" Count="0" />
      <LineId Id="129" Count="5" />
      <LineId Id="408" Count="0" />
      <LineId Id="135" Count="16" />
      <LineId Id="409" Count="0" />
      <LineId Id="152" Count="1" />
      <LineId Id="320" Count="9" />
      <LineId Id="164" Count="4" />
      <LineId Id="410" Count="0" />
      <LineId Id="169" Count="1" />
      <LineId Id="424" Count="5" />
      <LineId Id="171" Count="0" />
      <LineId Id="430" Count="0" />
      <LineId Id="172" Count="0" />
      <LineId Id="308" Count="1" />
      <LineId Id="174" Count="4" />
      <LineId Id="411" Count="0" />
      <LineId Id="179" Count="5" />
      <LineId Id="412" Count="0" />
      <LineId Id="185" Count="5" />
      <LineId Id="413" Count="0" />
      <LineId Id="191" Count="5" />
      <LineId Id="414" Count="0" />
      <LineId Id="197" Count="1" />
      <LineId Id="310" Count="9" />
      <LineId Id="209" Count="4" />
      <LineId Id="415" Count="0" />
      <LineId Id="214" Count="16" />
      <LineId Id="416" Count="0" />
      <LineId Id="231" Count="3" />
      <LineId Id="330" Count="1" />
      <LineId Id="236" Count="4" />
      <LineId Id="417" Count="0" />
      <LineId Id="241" Count="5" />
      <LineId Id="418" Count="0" />
      <LineId Id="247" Count="5" />
      <LineId Id="419" Count="0" />
      <LineId Id="253" Count="5" />
      <LineId Id="420" Count="0" />
      <LineId Id="259" Count="5" />
      <LineId Id="421" Count="0" />
      <LineId Id="265" Count="1" />
      <LineId Id="332" Count="9" />
      <LineId Id="277" Count="4" />
      <LineId Id="422" Count="0" />
      <LineId Id="282" Count="1" />
      <LineId Id="342" Count="9" />
      <LineId Id="294" Count="4" />
      <LineId Id="423" Count="0" />
      <LineId Id="299" Count="1" />
      <LineId Id="302" Count="1" />
      <LineId Id="352" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runLengthIsExact">
      <LineId Id="1" Count="4" />
      <LineId Id="344" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="348" Count="3" />
      <LineId Id="347" Count="0" />
      <LineId Id="7" Count="2" />
      <LineId Id="345" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="353" Count="3" />
      <LineId Id="352" Count="0" />
      <LineId Id="11" Count="2" />
      <LineId Id="346" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="358" Count="3" />
      <LineId Id="357" Count="0" />
      <LineId Id="15" Count="2" />
      <LineId Id="362" Count="0" />
      <LineId Id="18" Count="3" />
      <LineId Id="363" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="31" Count="2" />
      <LineId Id="364" Count="0" />
      <LineId Id="34" Count="3" />
      <LineId Id="365" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="47" Count="2" />
      <LineId Id="367" Count="0" />
      <LineId Id="50" Count="3" />
      <LineId Id="369" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="371" Count="8" />
      <LineId Id="370" Count="0" />
      <LineId Id="55" Count="1" />
      <LineId Id="264" Count="1" />
      <LineId Id="58" Count="3" />
      <LineId Id="380" Count="0" />
      <LineId Id="62" Count="4" />
      <LineId Id="381" Count="0" />
      <LineId Id="67" Count="4" />
      <LineId Id="382" Count="0" />
      <LineId Id="72" Count="4" />
      <LineId Id="383" Count="0" />
      <LineId Id="77" Count="4" />
      <LineId Id="384" Count="0" />
      <LineId Id="82" Count="3" />
      <LineId Id="266" Count="1" />
      <LineId Id="87" Count="3" />
      <LineId Id="385" Count="0" />
      <LineId Id="91" Count="1" />
      <LineId Id="388" Count="4" />
      <LineId Id="387" Count="0" />
      <LineId Id="93" Count="2" />
      <LineId Id="386" Count="0" />
      <LineId Id="96" Count="1" />
      <LineId Id="103" Count="2" />
      <LineId Id="393" Count="0" />
      <LineId Id="106" Count="4" />
      <LineId Id="394" Count="0" />
      <LineId Id="111" Count="1" />
      <LineId Id="272" Count="9" />
      <LineId Id="123" Count="3" />
      <LineId Id="395" Count="0" />
      <LineId Id="127" Count="1" />
      <LineId Id="434" Count="4" />
      <LineId Id="433" Count="0" />
      <LineId Id="410" Count="0" />
      <LineId Id="282" Count="9" />
      <LineId Id="139" Count="3" />
      <LineId Id="396" Count="0" />
      <LineId Id="143" Count="1" />
      <LineId Id="428" Count="4" />
      <LineId Id="427" Count="0" />
      <LineId Id="145" Count="1" />
      <LineId Id="268" Count="1" />
      <LineId Id="148" Count="3" />
      <LineId Id="397" Count="0" />
      <LineId Id="152" Count="4" />
      <LineId Id="398" Count="0" />
      <LineId Id="157" Count="4" />
      <LineId Id="399" Count="0" />
      <LineId Id="162" Count="4" />
      <LineId Id="400" Count="0" />
      <LineId Id="167" Count="1" />
      <LineId Id="303" Count="9" />
      <LineId Id="179" Count="3" />
      <LineId Id="401" Count="0" />
      <LineId Id="183" Count="1" />
      <LineId Id="313" Count="9" />
      <LineId Id="195" Count="3" />
      <LineId Id="402" Count="0" />
      <LineId Id="199" Count="3" />
      <LineId Id="270" Count="1" />
      <LineId Id="204" Count="3" />
      <LineId Id="403" Count="0" />
      <LineId Id="208" Count="4" />
      <LineId Id="404" Count="0" />
      <LineId Id="213" Count="4" />
      <LineId Id="405" Count="0" />
      <LineId Id="218" Count="4" />
      <LineId Id="406" Count="0" />
      <LineId Id="223" Count="4" />
      <LineId Id="407" Count="0" />
      <LineId Id="228" Count="1" />
      <LineId Id="323" Count="9" />
      <LineId Id="240" Count="3" />
      <LineId Id="408" Count="0" />
      <LineId Id="244" Count="1" />
      <LineId Id="333" Count="9" />
      <LineId Id="256" Count="3" />
      <LineId Id="409" Count="0" />
      <LineId Id="260" Count="3" />
      <LineId Id="343" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runLengthIsMax">
      <LineId Id="1" Count="1" />
      <LineId Id="338" Count="156" />
      <LineId Id="644" Count="4" />
      <LineId Id="643" Count="0" />
      <LineId Id="495" Count="16" />
      <LineId Id="650" Count="4" />
      <LineId Id="649" Count="0" />
      <LineId Id="512" Count="130" />
      <LineId Id="265" Count="0" />
      <LineId Id="267" Count="1" />
      <LineId Id="337" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runLengthIsMin">
      <LineId Id="1" Count="1" />
      <LineId Id="329" Count="156" />
      <LineId Id="635" Count="4" />
      <LineId Id="634" Count="0" />
      <LineId Id="486" Count="16" />
      <LineId Id="641" Count="4" />
      <LineId Id="640" Count="0" />
      <LineId Id="503" Count="130" />
      <LineId Id="265" Count="2" />
      <LineId Id="328" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.runStartsWith">
      <LineId Id="1" Count="181" />
      <LineId Id="186" Count="2" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testContains">
      <LineId Id="125" Count="0" />
      <LineId Id="239" Count="1" />
      <LineId Id="238" Count="0" />
      <LineId Id="126" Count="38" />
      <LineId Id="167" Count="19" />
      <LineId Id="231" Count="4" />
      <LineId Id="230" Count="0" />
      <LineId Id="187" Count="42" />
      <LineId Id="242" Count="10" />
      <LineId Id="241" Count="0" />
      <LineId Id="41" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testContainsIgnoreCase">
      <LineId Id="1" Count="4" />
      <LineId Id="97" Count="0" />
      <LineId Id="99" Count="2" />
      <LineId Id="98" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="107" Count="2" />
      <LineId Id="51" Count="4" />
      <LineId Id="8" Count="10" />
      <LineId Id="46" Count="1" />
      <LineId Id="19" Count="2" />
      <LineId Id="48" Count="1" />
      <LineId Id="22" Count="1" />
      <LineId Id="25" Count="5" />
      <LineId Id="50" Count="0" />
      <LineId Id="32" Count="4" />
      <LineId Id="56" Count="0" />
      <LineId Id="37" Count="7" />
      <LineId Id="113" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="73" Count="11" />
      <LineId Id="92" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="102" Count="4" />
      <LineId Id="85" Count="1" />
      <LineId Id="110" Count="2" />
      <LineId Id="87" Count="3" />
      <LineId Id="72" Count="0" />
      <LineId Id="58" Count="12" />
      <LineId Id="57" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="142" Count="1" />
      <LineId Id="114" Count="27" />
      <LineId Id="144" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testContainsNo">
      <LineId Id="1" Count="0" />
      <LineId Id="58" Count="3" />
      <LineId Id="2" Count="1" />
      <LineId Id="55" Count="2" />
      <LineId Id="50" Count="4" />
      <LineId Id="4" Count="9" />
      <LineId Id="41" Count="8" />
      <LineId Id="19" Count="12" />
      <LineId Id="103" Count="0" />
      <LineId Id="32" Count="7" />
      <LineId Id="104" Count="0" />
      <LineId Id="63" Count="39" />
      <LineId Id="40" Count="0" />
      <LineId Id="129" Count="3" />
      <LineId Id="105" Count="23" />
      <LineId Id="133" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testContainsNoIgnoreCase">
      <LineId Id="1" Count="4" />
      <LineId Id="63" Count="3" />
      <LineId Id="62" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="59" Count="2" />
      <LineId Id="45" Count="4" />
      <LineId Id="8" Count="9" />
      <LineId Id="50" Count="8" />
      <LineId Id="23" Count="12" />
      <LineId Id="114" Count="0" />
      <LineId Id="36" Count="7" />
      <LineId Id="68" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="69" Count="44" />
      <LineId Id="67" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="142" Count="3" />
      <LineId Id="116" Count="25" />
      <LineId Id="146" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testEndsWith">
      <LineId Id="1" Count="1" />
      <LineId Id="74" Count="12" />
      <LineId Id="59" Count="0" />
      <LineId Id="5" Count="9" />
      <LineId Id="43" Count="8" />
      <LineId Id="20" Count="13" />
      <LineId Id="132" Count="0" />
      <LineId Id="34" Count="7" />
      <LineId Id="133" Count="0" />
      <LineId Id="87" Count="12" />
      <LineId Id="103" Count="28" />
      <LineId Id="42" Count="0" />
      <LineId Id="134" Count="28" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testEndsWithIgnoreCase">
      <LineId Id="1" Count="4" />
      <LineId Id="77" Count="3" />
      <LineId Id="6" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="83" Count="2" />
      <LineId Id="71" Count="1" />
      <LineId Id="75" Count="1" />
      <LineId Id="8" Count="9" />
      <LineId Id="46" Count="8" />
      <LineId Id="23" Count="13" />
      <LineId Id="143" Count="0" />
      <LineId Id="37" Count="7" />
      <LineId Id="86" Count="13" />
      <LineId Id="144" Count="0" />
      <LineId Id="100" Count="9" />
      <LineId Id="133" Count="8" />
      <LineId Id="118" Count="5" />
      <LineId Id="142" Count="0" />
      <LineId Id="124" Count="8" />
      <LineId Id="45" Count="0" />
      <LineId Id="115" Count="2" />
      <LineId Id="145" Count="26" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testEndsWithTrim">
      <LineId Id="1" Count="3" />
      <LineId Id="6" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="62" Count="12" />
      <LineId Id="61" Count="0" />
      <LineId Id="8" Count="9" />
      <LineId Id="46" Count="8" />
      <LineId Id="23" Count="13" />
      <LineId Id="138" Count="0" />
      <LineId Id="37" Count="7" />
      <LineId Id="140" Count="0" />
      <LineId Id="75" Count="12" />
      <LineId Id="139" Count="0" />
      <LineId Id="88" Count="1" />
      <LineId Id="142" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="143" Count="0" />
      <LineId Id="124" Count="13" />
      <LineId Id="108" Count="14" />
      <LineId Id="45" Count="0" />
      <LineId Id="146" Count="28" />
      <LineId Id="144" Count="1" />
      <LineId Id="175" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testIsEmpty">
      <LineId Id="1" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="2" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="43" Count="1" />
      <LineId Id="3" Count="0" />
      <LineId Id="5" Count="8" />
      <LineId Id="35" Count="4" />
      <LineId Id="17" Count="17" />
      <LineId Id="42" Count="0" />
      <LineId Id="49" Count="1" />
      <LineId Id="45" Count="3" />
      <LineId Id="51" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testIsEqualTo">
      <LineId Id="1" Count="1" />
      <LineId Id="60" Count="15" />
      <LineId Id="48" Count="0" />
      <LineId Id="5" Count="9" />
      <LineId Id="50" Count="8" />
      <LineId Id="20" Count="12" />
      <LineId Id="59" Count="0" />
      <LineId Id="33" Count="7" />
      <LineId Id="76" Count="13" />
      <LineId Id="96" Count="29" />
      <LineId Id="41" Count="0" />
      <LineId Id="135" Count="17" />
      <LineId Id="126" Count="8" />
      <LineId Id="153" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testIsEqualToIgnoreCase">
      <LineId Id="1" Count="4" />
      <LineId Id="63" Count="3" />
      <LineId Id="6" Count="0" />
      <LineId Id="68" Count="2" />
      <LineId Id="67" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="54" Count="1" />
      <LineId Id="71" Count="2" />
      <LineId Id="59" Count="2" />
      <LineId Id="8" Count="9" />
      <LineId Id="45" Count="8" />
      <LineId Id="23" Count="12" />
      <LineId Id="62" Count="0" />
      <LineId Id="36" Count="7" />
      <LineId Id="75" Count="19" />
      <LineId Id="124" Count="15" />
      <LineId Id="108" Count="5" />
      <LineId Id="115" Count="7" />
      <LineId Id="44" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="148" Count="20" />
      <LineId Id="140" Count="7" />
      <LineId Id="169" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testIsNotEmpty">
      <LineId Id="1" Count="0" />
      <LineId Id="40" Count="4" />
      <LineId Id="3" Count="0" />
      <LineId Id="5" Count="8" />
      <LineId Id="35" Count="4" />
      <LineId Id="17" Count="17" />
      <LineId Id="49" Count="2" />
      <LineId Id="45" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testIsNotEqualTo">
      <LineId Id="1" Count="1" />
      <LineId Id="65" Count="15" />
      <LineId Id="62" Count="0" />
      <LineId Id="4" Count="6" />
      <LineId Id="39" Count="2" />
      <LineId Id="47" Count="8" />
      <LineId Id="16" Count="13" />
      <LineId Id="64" Count="0" />
      <LineId Id="30" Count="7" />
      <LineId Id="126" Count="0" />
      <LineId Id="81" Count="43" />
      <LineId Id="38" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="138" Count="15" />
      <LineId Id="127" Count="10" />
      <LineId Id="154" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testIsNotEqualToIgnoreCase">
      <LineId Id="1" Count="5" />
      <LineId Id="71" Count="15" />
      <LineId Id="62" Count="0" />
      <LineId Id="8" Count="6" />
      <LineId Id="42" Count="2" />
      <LineId Id="50" Count="8" />
      <LineId Id="20" Count="12" />
      <LineId Id="67" Count="0" />
      <LineId Id="33" Count="7" />
      <LineId Id="87" Count="50" />
      <LineId Id="41" Count="0" />
      <LineId Id="148" Count="18" />
      <LineId Id="138" Count="9" />
      <LineId Id="167" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testLengthIsBetween">
      <LineId Id="1" Count="3" />
      <LineId Id="247" Count="0" />
      <LineId Id="310" Count="1" />
      <LineId Id="313" Count="6" />
      <LineId Id="312" Count="0" />
      <LineId Id="320" Count="3" />
      <LineId Id="332" Count="0" />
      <LineId Id="327" Count="0" />
      <LineId Id="335" Count="0" />
      <LineId Id="339" Count="0" />
      <LineId Id="342" Count="0" />
      <LineId Id="337" Count="0" />
      <LineId Id="331" Count="0" />
      <LineId Id="276" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="304" Count="1" />
      <LineId Id="14" Count="33" />
      <LineId Id="49" Count="1" />
      <LineId Id="277" Count="4" />
      <LineId Id="51" Count="5" />
      <LineId Id="282" Count="0" />
      <LineId Id="58" Count="23" />
      <LineId Id="83" Count="0" />
      <LineId Id="252" Count="9" />
      <LineId Id="94" Count="2" />
      <LineId Id="284" Count="4" />
      <LineId Id="97" Count="30" />
      <LineId Id="129" Count="0" />
      <LineId Id="262" Count="9" />
      <LineId Id="140" Count="2" />
      <LineId Id="289" Count="4" />
      <LineId Id="143" Count="27" />
      <LineId Id="308" Count="0" />
      <LineId Id="172" Count="1" />
      <LineId Id="175" Count="1" />
      <LineId Id="294" Count="4" />
      <LineId Id="177" Count="30" />
      <LineId Id="209" Count="1" />
      <LineId Id="299" Count="4" />
      <LineId Id="211" Count="27" />
      <LineId Id="309" Count="0" />
      <LineId Id="306" Count="0" />
      <LineId Id="240" Count="0" />
      <LineId Id="343" Count="1" />
      <LineId Id="283" Count="0" />
      <LineId Id="345" Count="22" />
      <LineId Id="307" Count="0" />
      <LineId Id="368" Count="10" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testLengthIsExact">
      <LineId Id="1" Count="1" />
      <LineId Id="229" Count="1" />
      <LineId Id="4" Count="0" />
      <LineId Id="270" Count="0" />
      <LineId Id="273" Count="17" />
      <LineId Id="271" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="266" Count="1" />
      <LineId Id="14" Count="31" />
      <LineId Id="47" Count="30" />
      <LineId Id="79" Count="0" />
      <LineId Id="237" Count="9" />
      <LineId Id="90" Count="31" />
      <LineId Id="123" Count="0" />
      <LineId Id="247" Count="9" />
      <LineId Id="134" Count="31" />
      <LineId Id="167" Count="30" />
      <LineId Id="199" Count="27" />
      <LineId Id="269" Count="0" />
      <LineId Id="268" Count="0" />
      <LineId Id="228" Count="0" />
      <LineId Id="291" Count="13" />
      <LineId Id="257" Count="8" />
      <LineId Id="305" Count="5" />
      <LineId Id="272" Count="0" />
      <LineId Id="311" Count="7" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testLengthIsMax">
      <LineId Id="1" Count="1" />
      <LineId Id="229" Count="1" />
      <LineId Id="4" Count="1" />
      <LineId Id="271" Count="18" />
      <LineId Id="11" Count="2" />
      <LineId Id="267" Count="0" />
      <LineId Id="270" Count="0" />
      <LineId Id="14" Count="31" />
      <LineId Id="47" Count="30" />
      <LineId Id="79" Count="0" />
      <LineId Id="231" Count="9" />
      <LineId Id="90" Count="31" />
      <LineId Id="123" Count="0" />
      <LineId Id="241" Count="9" />
      <LineId Id="134" Count="31" />
      <LineId Id="167" Count="30" />
      <LineId Id="199" Count="27" />
      <LineId Id="269" Count="0" />
      <LineId Id="268" Count="0" />
      <LineId Id="228" Count="0" />
      <LineId Id="290" Count="6" />
      <LineId Id="251" Count="15" />
      <LineId Id="297" Count="14" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testLengthIsMin">
      <LineId Id="1" Count="1" />
      <LineId Id="229" Count="1" />
      <LineId Id="4" Count="1" />
      <LineId Id="262" Count="18" />
      <LineId Id="11" Count="2" />
      <LineId Id="258" Count="1" />
      <LineId Id="14" Count="31" />
      <LineId Id="47" Count="30" />
      <LineId Id="79" Count="0" />
      <LineId Id="238" Count="9" />
      <LineId Id="90" Count="31" />
      <LineId Id="123" Count="0" />
      <LineId Id="248" Count="9" />
      <LineId Id="134" Count="31" />
      <LineId Id="167" Count="30" />
      <LineId Id="199" Count="27" />
      <LineId Id="260" Count="1" />
      <LineId Id="228" Count="0" />
      <LineId Id="281" Count="37" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testStartsWith">
      <LineId Id="1" Count="1" />
      <LineId Id="105" Count="3" />
      <LineId Id="110" Count="7" />
      <LineId Id="60" Count="0" />
      <LineId Id="4" Count="9" />
      <LineId Id="42" Count="8" />
      <LineId Id="19" Count="13" />
      <LineId Id="61" Count="0" />
      <LineId Id="33" Count="7" />
      <LineId Id="119" Count="0" />
      <LineId Id="62" Count="17" />
      <LineId Id="118" Count="0" />
      <LineId Id="81" Count="22" />
      <LineId Id="41" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="132" Count="3" />
      <LineId Id="109" Count="0" />
      <LineId Id="136" Count="9" />
      <LineId Id="120" Count="11" />
      <LineId Id="146" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testStartsWithIgnoreCase">
      <LineId Id="1" Count="4" />
      <LineId Id="70" Count="0" />
      <LineId Id="72" Count="2" />
      <LineId Id="6" Count="1" />
      <LineId Id="60" Count="4" />
      <LineId Id="66" Count="2" />
      <LineId Id="8" Count="9" />
      <LineId Id="51" Count="8" />
      <LineId Id="23" Count="21" />
      <LineId Id="125" Count="0" />
      <LineId Id="76" Count="23" />
      <LineId Id="101" Count="23" />
      <LineId Id="75" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="144" Count="11" />
      <LineId Id="126" Count="17" />
      <LineId Id="156" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf16StringAssertionTests.testStartsWithTrim">
      <LineId Id="1" Count="3" />
      <LineId Id="127" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="113" Count="3" />
      <LineId Id="118" Count="7" />
      <LineId Id="64" Count="0" />
      <LineId Id="9" Count="9" />
      <LineId Id="47" Count="8" />
      <LineId Id="24" Count="13" />
      <LineId Id="66" Count="0" />
      <LineId Id="38" Count="7" />
      <LineId Id="126" Count="0" />
      <LineId Id="68" Count="14" />
      <LineId Id="128" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="84" Count="4" />
      <LineId Id="90" Count="22" />
      <LineId Id="67" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="143" Count="3" />
      <LineId Id="117" Count="0" />
      <LineId Id="147" Count="11" />
      <LineId Id="130" Count="12" />
      <LineId Id="159" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>