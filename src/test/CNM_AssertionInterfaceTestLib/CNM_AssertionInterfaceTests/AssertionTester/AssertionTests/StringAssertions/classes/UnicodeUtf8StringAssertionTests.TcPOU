<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.13">
  <POU Name="UnicodeUtf8StringAssertionTests" Id="{67c8b9fc-161f-4145-8062-e7dc976ff547}" SpecialFunc="None">
    <Declaration><![CDATA[
(*
short summary
==================
This class tests all methods of Unicode string assertions
with various UTF-8 string combinations as input and checks expected 
outputs are satisfied or not

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

methods and properties
======================

*)


FUNCTION_BLOCK UnicodeUtf8StringAssertionTests EXTENDS AbstractAssertorTest
VAR

END_VAR
VAR CONSTANT
	(* prefix to unify the test names *)
	TEST_NAME_PREFIX :STRING := 'assert.string.unicode(utf8).';
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[THIS^.runIsEmpty();
THIS^.runIsNotEmpty();
THIS^.runContains();
THIS^.runContainsNo();
THIS^.runEndsWith();
THIS^.runStartsWith();
THIS^.runIsEqualTo();
THIS^.runIsNotEqualTo();
THIS^.runLengthIsBetween();
THIS^.runLengthIsExact();
THIS^.runLengthIsMax();
THIS^.runLengthIsMin();]]></ST>
    </Implementation>
    <Folder Name="contains" Id="{effa8489-9118-42db-81e4-13ffa2c88661}">
      <Folder Name="ignoreCase" Id="{220e4dad-56ba-41b5-88f8-099222313fd2}" />
    </Folder>
    <Folder Name="containsNo" Id="{fe9176d5-77e7-432e-96f2-feaebf77996c}">
      <Folder Name="ignoreCase" Id="{59f3ed04-12cc-454c-9eab-9cd0930b1bde}" />
    </Folder>
    <Folder Name="endsWith" Id="{63a35011-8184-470c-a2d9-81cd5e79d411}">
      <Folder Name="ignoreCase" Id="{3bf8b9bd-b361-4406-a8fa-60d3f238f9c5}" />
      <Folder Name="trim" Id="{7ae9b02e-5cf1-423a-800b-aa72e64e3455}" />
    </Folder>
    <Folder Name="internal" Id="{42f59389-699a-4144-b06b-793a48a7d97f}" />
    <Folder Name="isEmpty" Id="{eacf28c2-ebf0-426b-b604-ac124619c503}" />
    <Folder Name="isEqualTo" Id="{9296971a-603a-4768-9167-c26d017a7882}">
      <Folder Name="ignoreCase" Id="{bf9ae96f-c30b-4927-8bd7-c9be6012b39e}" />
    </Folder>
    <Folder Name="isNotEmpty" Id="{54a0796d-ce40-4c0b-9802-4ad2d87b268f}" />
    <Folder Name="isNotEqualTo" Id="{c26a7313-0b25-45ab-922f-47871a16baa3}">
      <Folder Name="ignoreCase" Id="{af138ba5-f97c-45c1-b055-dd8402ea7588}" />
    </Folder>
    <Folder Name="lengthIsBetween" Id="{43b108e5-b79b-49c5-8e65-3fb22e8f9dd9}" />
    <Folder Name="lengthIsExact" Id="{dc63cfc3-4058-43e6-81c7-8cdffebad222}" />
    <Folder Name="lengthIsMax" Id="{b2628c99-515b-4771-bedd-7619cade237a}" />
    <Folder Name="lengthIsMin" Id="{4565d6da-0902-4758-831c-29accc4c2e74}" />
    <Folder Name="startsWith" Id="{87a95d77-c848-4622-b0ee-07779f695cd4}">
      <Folder Name="ignoreCase" Id="{4f0da1c9-f7b1-47e5-8f68-ce0c5bf43405}" />
      <Folder Name="trim" Id="{58456c00-6eba-4cc3-814e-8de28e69c36f}" />
    </Folder>
    <Method Name="getTestNameFor" Id="{58cc03e9-374e-4999-b792-a9f00badbadc}" FolderPath="internal\">
      <Declaration><![CDATA[(*

short summary
==================
This test method is a helper function to create a unified test name

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD PROTECTED getTestNameFor :Tc2_System.T_MaxString
VAR_INPUT
	(* name of the method to test, to create a unified test name *)
	nameOfMethodToTest	:Tc2_System.T_MaxString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getTestNameFor := Tc2_Standard.CONCAT(THIS^.TEST_NAME_PREFIX, nameOfMethodToTest);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runContains" Id="{fb59919e-9712-48e5-a62d-8cd13d40f6da}" FolderPath="contains\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.contains``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runContains : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('contains')));

THIS^.testContains(
	stringToTest := '',
	expectedString := ''
);
THIS^.testContains(
	stringToTest := 'not empty',
	expectedString := ''
);
THIS^.testContains(
	stringToTest := '',
	expectedString := 'not empty'
);
THIS^.testContains(
	stringToTest := 'not empty',
	expectedString := 'not empty'
);
THIS^.testContains(
	stringToTest := '{|}~',
	expectedString := '3649213469328'
);
THIS^.testContains(
	stringToTest := '1one!',
	expectedString := '1'
);
THIS^.testContains(
	stringToTest := '1one!',
	expectedString := 'one'
);
THIS^.testContains(
	stringToTest := '1one!',
	expectedString := '!'
);
THIS^.testContains(
	stringToTest := '$40$n$t$$$"$'',
	expectedString := '$n$t'
);
THIS^.testContains(
	stringToTest := 'frontmiddleback',
	expectedString := 'back'
);
THIS^.testContains(
	stringToTest := 'frontmiddleback',
	expectedString := 'frontmiddlebackfront'
);
THIS^.testContains(
	stringToTest := 'backfrontmiddle',
	expectedString := 'backmiddle'
);
THIS^.testContains(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y'
);
THIS^.testContains(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x'
);
THIS^.testContains(
	stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)',
	expectedString := UTF8#'∑ f(i) = ∏ g(i)'
);
THIS^.testContains(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ'
);
THIS^.testContains(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ ⇒ (A ⇔ B)'
);
THIS^.testContains(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'2H₂ + O₂ ⇌ 2H₂O'
);
THIS^.testContains(
	stringToTest := UTF8#'ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]',
	expectedString := UTF8#'ˈnæʃənəl fəˈnɛtık '
);
THIS^.testContains(
	stringToTest := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €',
	expectedString := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €'
);
THIS^.testContains(
	stringToTest := UTF8#'Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,',
	expectedString := UTF8#'τὴν κόψη τοῦ σπαθ'
);
THIS^.testContains(
	stringToTest := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად',
	expectedString := UTF8#'გაიაროთ რეგისტრაცია Unicode-ის გაიმართება'
);
THIS^.testContains(
	stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в',
	expectedString := UTF8#'Международную Конференцию по Unicode, которая'
);
THIS^.testContains(
	stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่',
	expectedString := UTF8#'สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา  ' 
);
THIS^.testContains(
	stringToTest := UTF8#' ሰማይ አይታረስ ንጉሥ አይከሰስ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።',
	expectedString := UTF8#'አይታረስ ንጉሥ አይከሰስ። ብላ በቆመጠኝ።'
);
THIS^.testContains(
	stringToTest := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ',
	expectedString := UTF8#'ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ'
);
THIS^.testContains(
	stringToTest := UTF8#'⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞',
	expectedString := UTF8#'⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋'
);
THIS^.testContains(
	stringToTest := UTF8#'╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳',
	expectedString := UTF8#'╦══╗  ┌──┬──┐  ╭──╦══╗'
);
THIS^.testContainsIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'CASE'
);
THIS^.testContainsIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'case'
);
THIS^.testContainsIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'case'
);
THIS^.testContainsIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'CASE'
);
THIS^.testContainsIgnoreCase(
	stringToTest := 'lower',
	expectedString := 'UPPER'
);
THIS^.testContainsIgnoreCase(
	stringToTest := UTF8#'UPPERCASE⌷←⍳→⍴∆∇⊃‾⍎⍕⌈',
	expectedString := UTF8#'case⌷←⍳→⍴∆∇⊃‾⍎⍕⌈'
);
THIS^.testContainsIgnoreCase(
	stringToTest := UTF8#'UPPERCASE((V⍳V)=⍳⍴V)/V←,V',
	expectedString := UTF8#'case((V⍳V)=⍳⍴V)/V←'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runContainsNo" Id="{da43f0de-d196-494b-a7f9-62430cc4156a}" FolderPath="containsNo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.containsNo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runContainsNo : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('containsNo')));

THIS^.testContainsNo(
	stringToTest := '',
	expectedString := ''
);
THIS^.testContainsNo(
	stringToTest := 'not empty',
	expectedString := ''
);
THIS^.testContainsNo(
	stringToTest := '',
	expectedString := 'not empty'
);
THIS^.testContainsNo(
	stringToTest := 'not empty',
	expectedString := 'not empty'
);
THIS^.testContainsNo(
	stringToTest := '{|}~',
	expectedString := '3649213469328'
);
THIS^.testContainsNo(
	stringToTest := '1one!',
	expectedString := '1'
);
THIS^.testContainsNo(
	stringToTest := '1one!',
	expectedString := 'one'
);
THIS^.testContainsNo(
	stringToTest := '1one!',
	expectedString := '!'
);
THIS^.testContainsNo(
	stringToTest := '$40$n$t$$$"$'',
	expectedString := '$n$t'
);
THIS^.testContainsNo(
	stringToTest := 'frontmiddleback',
	expectedString := 'back'
);
THIS^.testContainsNo(
	stringToTest := 'frontmiddleback',
	expectedString := 'frontmiddlebackfront'
);
THIS^.testContainsNo(
	stringToTest := 'backfrontmiddle',
	expectedString := 'backmiddle'
);
THIS^.testContainsNo(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y'
);
THIS^.testContainsNo(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)',
	expectedString := UTF8#'∑ f(i) = ∏ g(i)'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ ⇒ (A ⇔ B)'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'2H₂ + O₂ ⇌ 2H₂O'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]',
	expectedString := UTF8#'ˈnæʃənəl fəˈnɛtık '
);
THIS^.testContainsNo(
	stringToTest := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €',
	expectedString := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,',
	expectedString := UTF8#'τὴν κόψη τοῦ σπαθ'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად',
	expectedString := UTF8#'გაიაროთ რეგისტრაცია Unicode-ის გაიმართება'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в',
	expectedString := UTF8#'Международную Конференцию по Unicode, которая'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่',
	expectedString := UTF8#'สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา  ' 
);
THIS^.testContainsNo(
	stringToTest := UTF8#' ሰማይ አይታረስ ንጉሥ አይከሰስ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።',
	expectedString := UTF8#'አይታረስ ንጉሥ አይከሰስ። ብላ በቆመጠኝ።'
);
THIS^.testContainsNo(
	stringToTest := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ',
	expectedString := UTF8#'ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞',
	expectedString := UTF8#'⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋'
);
THIS^.testContainsNo(
	stringToTest := UTF8#'╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳',
	expectedString := UTF8#'╦══╗  ┌──┬──┐  ╭──╦══╗'
);

THIS^.testContainsNoIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'CASE'
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'case'
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'case'
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'CASE'
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := 'lower',
	expectedString := 'UPPER'
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := UTF8#'UPPERCASE⌷←⍳→⍴∆∇⊃‾⍎⍕⌈',
	expectedString := UTF8#'case⌷←⍳→⍴∆∇⊃‾⍎⍕⌈'
);
THIS^.testContainsNoIgnoreCase(
	stringToTest := UTF8#'UPPERCASE((V⍳V)=⍳⍴V)/V←,V',
	expectedString := UTF8#'case((V⍳V)=⍳⍴V)/V←'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runEndsWith" Id="{1387bb5f-38ba-4ec5-a68a-3ededa2097a0}" FolderPath="endsWith\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.endsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runEndsWith : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('endsWith')));

THIS^.testEndsWith(
	stringToTest := '',
	expectedString := ''
);
THIS^.testEndsWith(
	stringToTest := 'not empty',
	expectedString := ''
);
THIS^.testEndsWith(
	stringToTest := '',
	expectedString := 'not empty'
);
THIS^.testEndsWith(
	stringToTest := 'not empty',
	expectedString := 'not empty'
);
THIS^.testEndsWith(
	stringToTest := '{|}~',
	expectedString := '3649213469328'
);
THIS^.testEndsWith(
	stringToTest := '1one!',
	expectedString := '1'
);
THIS^.testEndsWith(
	stringToTest := '1one!',
	expectedString := 'one'
);
THIS^.testEndsWith(
	stringToTest := '1one!',
	expectedString := '!'
);
THIS^.testEndsWith(
	stringToTest := '$40$n$t$$$"$'',
	expectedString := '$n$t'
);
THIS^.testEndsWith(
	stringToTest := '$40$$$"$'$n$t',
	expectedString := '$n$t'
);
THIS^.testEndsWith(
	stringToTest := 'frontmiddleback',
	expectedString := 'back'
);
THIS^.testEndsWith(
	stringToTest := 'frontmiddleback',
	expectedString := 'frontmiddlebackfront'
);
THIS^.testEndsWith(
	stringToTest := 'backfrontmiddle',
	expectedString := 'backmiddle'
);
THIS^.testEndsWith(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y'
);
THIS^.testEndsWith(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)',
	expectedString := UTF8#'α ∧ ¬β = ¬(¬α ∨ β)'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ ⇒ (A ⇔ B)'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'2H₂ + O₂ ⇌ 2H₂O'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]ˈnæʃənəl fəˈnɛtık ',
	expectedString := UTF8#'ˈnæʃənəl fəˈnɛtık '
);
THIS^.testEndsWith(
	stringToTest := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €',
	expectedString := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,',
	expectedString := UTF8#'τὴν κόψη τοῦ σπαθ'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად',
	expectedString := UTF8#'რომელიც გაიმართება'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в',
	expectedString := UTF8#'Международную Конференцию по Unicode, которая'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่',
	expectedString := UTF8#'สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา ' 
);
THIS^.testEndsWith(
	stringToTest := UTF8#' ሰማይ አይታረስ ንጉሥ አይከሰስ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።',
	expectedString := UTF8#'አይታረስ ንጉሥ አይከሰስ። በቆመጠኝ።'
);
THIS^.testEndsWith(
	stringToTest := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ',
	expectedString := UTF8#'ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞',
	expectedString := UTF8#'⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙'
);
THIS^.testEndsWith(
	stringToTest := UTF8#'╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳',
	expectedString := UTF8#'┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳'
);

THIS^.testEndsWithIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'CASE'
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'case'
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'case'
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'CASE'
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := 'lower',
	expectedString := 'UPPER'
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := UTF8#'UPPERCASE⌷←⍳→⍴∆∇⊃‾⍎⍕⌈',
	expectedString := UTF8#'case⌷←⍳→⍴∆∇⊃‾⍎⍕⌈'
);
THIS^.testEndsWithIgnoreCase(
	stringToTest := UTF8#'UPPERCASE((V⍳V)=⍳⍴V)/V←,V',
	expectedString := UTF8#'case((V⍳V)=⍳⍴V)/V←'
);

THIS^.testEndsWithTrim(
	stringToTest := 'frontmiddleback$t',
	expectedString := 'back'
);
THIS^.testEndsWithTrim(
	stringToTest := 'frontmiddleback',
	expectedString := 'back$t'
);
THIS^.testEndsWithTrim(
	stringToTest := 'frontmiddleback$20',
	expectedString := 'back'
);
THIS^.testEndsWithTrim(
	stringToTest := 'frontmiddleback',
	expectedString := 'back$20'
);
THIS^.testEndsWithTrim(
	stringToTest := 'frontmiddleback$t$n$r$p$l',
	expectedString := 'back$r$t$n$l$p$20'
);
THIS^.testEndsWithTrim(
	stringToTest := 'frontmiddleback$t$n$r$p$l',
	expectedString := 'back$t$n$r$p$l$20'
);
THIS^.testEndsWithTrim(
	stringToTest := UTF8#'frontmiddleback⌷←⍳→⍴∆∇⊃‾⍎$t$n$r$p$l',
	expectedString := UTF8#'back⌷←⍳→⍴∆∇⊃‾⍎'
);
THIS^.testEndsWithTrim(
	stringToTest := UTF8#'frontmiddleback⌷←⍳→⍴∆∇⊃‾⍎$t$n$r$p$l',
	expectedString := UTF8#'back⌷→⍴∆∇⊃‾⍎'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runIsEmpty" Id="{1a424e42-c5e7-470b-af8f-46180d159144}" FolderPath="isEmpty\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.IsEmpty``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runIsEmpty : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('IsEmpty')));

THIS^.testIsEmpty(
	stringToTest := ''
);
THIS^.testIsEmpty(
	stringToTest := 'not empty'
);
THIS^.testIsEmpty(
	stringToTest := '{|}~'
);
THIS^.testIsEmpty(
	stringToTest := '3649213469328'
);
THIS^.testIsEmpty(
	stringToTest := '1one!'
);
THIS^.testIsEmpty(
	stringToTest := '$40$n$t$$$"$''
);
THIS^.testIsEmpty(
	stringToTest := '$n$t'
);
THIS^.testIsEmpty(
	stringToTest := 'frontmiddleback'
);
THIS^.testIsEmpty(
	stringToTest := 'backfrontmiddle'
);
THIS^.testIsEmpty(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y'
);
THIS^.testIsEmpty(
	stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#'ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#'Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#' ሰማይ አይታረስ ንጉሥ አይከሰስ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#'⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞',
);
THIS^.testIsEmpty(
	stringToTest := UTF8#'╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳',
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runIsEqualTo" Id="{d84d71c6-0ac9-4898-84c9-835357ab423e}" FolderPath="isEqualTo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runIsEqualTo : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('isEqualTo')));

THIS^.testisEqualTo(
	stringToTest := '',
	expectedString := ''
);
THIS^.testisEqualTo(
	stringToTest := 'not empty',
	expectedString := ''
);
THIS^.testisEqualTo(
	stringToTest := '',
	expectedString := 'not empty'
);
THIS^.testisEqualTo(
	stringToTest := 'not empty',
	expectedString := 'not'
);
THIS^.testisEqualTo(
	stringToTest := 'not empty',
	expectedString := 'not empty'
);
THIS^.testisEqualTo(
	stringToTest := '{|}~',
	expectedString := '3649213469328'
);
THIS^.testisEqualTo(
	stringToTest := '1one!',
	expectedString := '1one'
);
THIS^.testisEqualTo(
	stringToTest := '1one!',
	expectedString := '1one!'
);

THIS^.testisEqualTo(
	stringToTest := '$40$n$t$$$"$'',
	expectedString := '$n$t'
);
THIS^.testisEqualTo(
	stringToTest := '$40$n$t$$$"$'',
	expectedString := '$40$n$t$$$"$''
);
THIS^.testisEqualTo(
	stringToTest := 'frontmiddleback',
	expectedString := 'back'
);
THIS^.testisEqualTo(
	stringToTest := 'frontmiddleback',
	expectedString := 'frontmiddlebackfront'
);
THIS^.testisEqualTo(
	stringToTest := 'backfrontmiddle',
	expectedString := 'backmiddle'
);
THIS^.testisEqualTo(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y'
);
THIS^.testisEqualTo(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)',
	expectedString := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]',
	expectedString := UTF8#'ˈnæʃənəl fəˈnɛtık '
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €',
	expectedString := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,',
	expectedString := UTF8#'τὴν κόψη τοῦ σπαθ'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად',
	expectedString := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в',
	expectedString := UTF8#'Международную Конференцию по Unicode, которая'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่',
	expectedString := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#' ሰማይ አይታረስ ንጉሥ አይከሰስ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።',
	expectedString := UTF8#'አይታረስ ንጉሥ አይከሰስ። ብላ በቆመጠኝ።'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ',
	expectedString := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞',
	expectedString := UTF8#'⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋'
);
THIS^.testisEqualTo(
	stringToTest := UTF8#'╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳',
	expectedString := UTF8#'╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳'
);

THIS^.testisEqualToIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'UPPERCASE'
);
THIS^.testisEqualToIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'lowercase'
);
THIS^.testisEqualToIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'lowercase'
);
THIS^.testisEqualToIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'UPPERCASE'
);
THIS^.testisEqualToIgnoreCase(
	stringToTest := UTF8#'UPPERCASE⌷←⍳→⍴∆∇⊃‾⍎⍕⌈',
	expectedString := UTF8#'uppercase⌷←⍳→⍴∆∇⊃‾⍎⍕⌈'
);
THIS^.testisEqualToIgnoreCase(
	stringToTest := UTF8#'UPPERCASE((V⍳V)=⍳⍴V)/V←,V',
	expectedString := UTF8#'uppercase((V⍳V)=⍳⍴V)/V←'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runIsNotEmpty" Id="{6dbecb14-75b5-439d-a0bb-8d21a747073d}" FolderPath="isNotEmpty\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.IsNotEmpty``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runIsNotEmpty : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('IsNotEmpty')));

THIS^.testIsNotEmpty(
	stringToTest := ''
);
THIS^.testIsNotEmpty(
	stringToTest := 'not empty'
);
THIS^.testIsNotEmpty(
	stringToTest := '{|}~'
);
THIS^.testIsNotEmpty(
	stringToTest := '3649213469328'
);
THIS^.testIsNotEmpty(
	stringToTest := '1one!'
);
THIS^.testIsNotEmpty(
	stringToTest := '$40$n$t$$$"$''
);
THIS^.testIsNotEmpty(
	stringToTest := '$n$t'
);
THIS^.testIsNotEmpty(
	stringToTest := 'frontmiddleback'
);
THIS^.testIsNotEmpty(
	stringToTest := 'backfrontmiddle'
);
THIS^.testIsNotEmpty(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y'
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)',
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#'ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]',
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €',
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#'Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,',
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად',
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в',
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่'
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#' ሰማይ አይታረስ ንጉሥ አይከሰስ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።',
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ',
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#'⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞',
);
THIS^.testIsNotEmpty(
	stringToTest := UTF8#'╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳',
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runIsNotEqualTo" Id="{17549eb6-e895-4c0f-a1b7-e298ada56ede}" FolderPath="isNotEqualTo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isNotEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runIsNotEqualTo : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('isNotEqualTo')));

THIS^.testisNotEqualTo(
	stringToTest := '',
	expectedString := ''
);
THIS^.testisNotEqualTo(
	stringToTest := 'not empty',
	expectedString := ''
);
THIS^.testisNotEqualTo(
	stringToTest := '',
	expectedString := 'not empty'
);
THIS^.testisNotEqualTo(
	stringToTest := 'not empty',
	expectedString := 'not'
);
THIS^.testisNotEqualTo(
	stringToTest := 'not empty',
	expectedString := 'not empty'
);
THIS^.testisNotEqualTo(
	stringToTest := '{|}~',
	expectedString := '3649213469328'
);
THIS^.testisNotEqualTo(
	stringToTest := '1one!',
	expectedString := '1one'
);
THIS^.testisNotEqualTo(
	stringToTest := '1one!',
	expectedString := '1one!'
);

THIS^.testisNotEqualTo(
	stringToTest := '$40$n$t$$$"$'',
	expectedString := '$n$t'
);
THIS^.testisNotEqualTo(
	stringToTest := '$40$n$t$$$"$'',
	expectedString := '$40$n$t$$$"$''
);
THIS^.testisNotEqualTo(
	stringToTest := 'frontmiddleback',
	expectedString := 'back'
);
THIS^.testisNotEqualTo(
	stringToTest := 'frontmiddleback',
	expectedString := 'frontmiddlebackfront'
);
THIS^.testisNotEqualTo(
	stringToTest := 'backfrontmiddle',
	expectedString := 'backmiddle'
);
THIS^.testisNotEqualTo(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y'
);
THIS^.testisNotEqualTo(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)',
	expectedString := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]',
	expectedString := UTF8#'ˈnæʃənəl fəˈnɛtık '
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €',
	expectedString := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,',
	expectedString := UTF8#'τὴν κόψη τοῦ σπαθ'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად',
	expectedString := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в',
	expectedString := UTF8#'Международную Конференцию по Unicode, которая'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่',
	expectedString := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#' ሰማይ አይታረስ ንጉሥ አይከሰስ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።',
	expectedString := UTF8#'አይታረስ ንጉሥ አይከሰስ። ብላ በቆመጠኝ።'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ',
	expectedString := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞',
	expectedString := UTF8#'⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋'
);
THIS^.testisNotEqualTo(
	stringToTest := UTF8#'╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳',
	expectedString := UTF8#'╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳'
);

THIS^.testisNotEqualToIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'UPPERCASE'
);
THIS^.testisNotEqualToIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'lowercase'
);
THIS^.testisNotEqualToIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'lowercase'
);
THIS^.testisNotEqualToIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'UPPERCASE'
);
THIS^.testisNotEqualToIgnoreCase(
	stringToTest := UTF8#'UPPERCASE⌷←⍳→⍴∆∇⊃‾⍎⍕⌈',
	expectedString := UTF8#'uppercase⌷←⍳→⍴∆∇⊃‾⍎⍕⌈'
);
THIS^.testisNotEqualToIgnoreCase(
	stringToTest := UTF8#'UPPERCASE((V⍳V)=⍳⍴V)/V←,V',
	expectedString := UTF8#'uppercase((V⍳V)=⍳⍴V)/V←'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runLengthIsBetween" Id="{4787e61e-68bc-48ed-9f34-6183934e53ea}" FolderPath="lengthIsBetween\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsBetween``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runLengthIsBetween : BOOL
VAR
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest :Tc2_System.T_MaxString;
	(* length of current string to check in bytes *)
	stringToTestByteCount		:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount	:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength :UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	{attribute 'TcEncoding' := 'UTF-8'}
	normalizedStringToTest :Tc2_System.T_MaxString;
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth :DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters :UDINT := 0;
END_VAR


]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('lengthIsBetween')));

THIS^.testLengthIsBetween(
	stringToTest := '',
	maxLength := 0,
	minLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsBetween(
	stringToTest := '',
	maxLength := 0,
	minLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsBetween(
	stringToTest := '',
	maxLength := 0,
	minLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := '',
	maxLength := 0,
	minLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := 'not empty',
	maxLength := 9,
	minLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := 'not empty',
	maxLength := 13,
	minLength := 10,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := 'not empty',
	maxLength := 9,
	minLength := 9,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsBetween(
	stringToTest := 'not empty',
	maxLength := 13,
	minLength := 10,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsBetween(
	stringToTest := '1one!',
	maxLength := 5,
	minLength := 4,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := '1one!',
	maxLength := 5,
	minLength := 4,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH
);
THIS^.testLengthIsBetween(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	maxLength := 255,
	minLength := 255,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	maxLength := 255,
	minLength := 255,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsBetween(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	maxLength := 254,
	minLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsBetween(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	maxLength := 254,
	minLength := 254,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);

stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestByteCount,
	minLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount,
	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestByteCount - 1,
	minLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := TO_UDINT(stringToTestWidth),
	minLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestVisibleCharacters,
	minLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);

stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestByteCount,
	minLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount,
	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount + 1,
	minLength := stringToTestCodePointCount - 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := TO_UDINT(stringToTestWidth),
	minLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
); 
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestVisibleCharacters,
	minLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount,
	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount,
	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
	maxLength := stringToTestCodePointCount,
	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);

stringToTest := UTF8#'Ä๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่  สิบสองกษัตริย์ก่อนหน้าแล ';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestByteCount,
  	minLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
 	maxLength := stringToTestCodePointCount,
 	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
 	maxLength := TO_UDINT(stringToTestWidth),
  	minLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestVisibleCharacters,
  	minLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);

stringToTest := UTF8#'🧌🦤🏭💽🧧🪷👨‍💻👩‍👩‍👧‍👦';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestByteCount,
  	minLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount + 1,
  	minLength := stringToTestCodePointCount - 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := TO_UDINT(stringToTestWidth),
  	minLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestVisibleCharacters,
  	minLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsBetween(
	stringToTest := stringToTest,
  	maxLength := stringToTestCodePointCount,
  	minLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runLengthIsExact" Id="{d02daa0e-942f-492a-88cf-9ae591fef81a}" FolderPath="lengthIsExact\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsExact``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runLengthIsExact : BOOL
VAR
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest :Tc2_System.T_MaxString;
	(* length of current string to check in bytes *)
	stringToTestByteCount		:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount	:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength :UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	{attribute 'TcEncoding' := 'UTF-8'}
	normalizedStringToTest :Tc2_System.T_MaxString;
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth :DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters :UDINT := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('lengthIsExact')));

THIS^.testLengthIsExact(
	stringToTest := '',
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := '',
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := '',
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := '',
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := 'not empty',
	expectedLength := 9,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := 'not empty',
	expectedLength := 18,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := 'not empty',
	expectedLength := 8,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := 'not empty',
	expectedLength := 19,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := '1one!',
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := '1one!',
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH
);
THIS^.testLengthIsExact(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 510,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 511,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsExact(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 255,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsExact(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 254,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);

stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount - 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);

stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
); 
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);

stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่  สิบสองกษัตริย์ก่อนหน้าแล ';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
 	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
 	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);

stringToTest := UTF8#'🧌🦤🏭💽🧧🪷👨‍💻👩‍👩‍👧‍👦';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsExact(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runLengthIsMax" Id="{a3b5a3e1-be6e-4d21-991a-e1129d9ab124}" FolderPath="lengthIsMax\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsMax``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runLengthIsMax : BOOL
VAR
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest :Tc2_System.T_MaxString;
	(* length of current string to check in bytes *)
	stringToTestByteCount		:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount	:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength :UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	{attribute 'TcEncoding' := 'UTF-8'}
	normalizedStringToTest :Tc2_System.T_MaxString;
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth :DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters :UDINT := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('lengthIsMax')));

THIS^.testLengthIsMax(
	stringToTest := '',
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := '',
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := '',
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := '',
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := 'not empty',
	expectedLength := 9,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := 'not empty',
	expectedLength := 18,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := 'not empty',
	expectedLength := 8,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := 'not empty',
	expectedLength := 19,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := '1one!',
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := '1one!',
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH
);
THIS^.testLengthIsMax(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 510,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 511,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMax(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 255,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMax(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 254,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);

stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount - 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);

stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
); 
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);

stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่  สิบสองกษัตริย์ก่อนหน้าแล ';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
 	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
 	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);

stringToTest := UTF8#'🧌🦤🏭💽🧧🪷👨‍💻👩‍👩‍👧‍👦';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMax(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runLengthIsMin" Id="{cb4b4d27-90df-4b37-aa76-53600bbbe90b}" FolderPath="lengthIsMin\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsMin``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runLengthIsMin : BOOL
VAR
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest :Tc2_System.T_MaxString;
	(* length of current string to check in bytes *)
	stringToTestByteCount		:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount	:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength :UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	{attribute 'TcEncoding' := 'UTF-8'}
	normalizedStringToTest :Tc2_System.T_MaxString;
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth :DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters :UDINT := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('lengthIsMin')));

THIS^.testLengthIsMin(
	stringToTest := '',
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := '',
	expectedLength := 0,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := '',
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := '',
	expectedLength := 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := 'not empty',
	expectedLength := 9,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := 'not empty',
	expectedLength := 18,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := 'not empty',
	expectedLength := 8,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := 'not empty',
	expectedLength := 19,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := '1one!',
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := '1one!',
	expectedLength := 5,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH
);
THIS^.testLengthIsMin(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 510,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 511,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES
);
THIS^.testLengthIsMin(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 255,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);
THIS^.testLengthIsMin(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedLength := 254,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS
);

stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount - 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'S E*da = Q,  n > inf ...'
);

stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestByteCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
); 
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
	stringToTestPrintable := 'Zaregistriruytes$' seychas ...'
);

stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่  สิบสองกษัตริย์ก่อนหน้าแล ';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
 	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
 	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
 	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := '* aephndinhanesueomothrmaesnsangewch  ...'
);

stringToTest := UTF8#'🧌🦤🏭💽🧧🪷👨‍💻👩‍👩‍👧‍👦';
CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestByteCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount + 1,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := TO_UDINT(stringToTestWidth),
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestVisibleCharacters,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringLength => normalizedLength
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	stringAddress := ADR(normalizedStringToTest),
	characterCount => stringToTestCodePointCount
);
THIS^.testLengthIsMin(
	stringToTest := stringToTest,
  	expectedLength := stringToTestCodePointCount,
	stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
  	stringToTestPrintable := ':troll::dodo::factory:...'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runStartsWith" Id="{05a6b9f4-424a-4757-80fc-eb0d1e6f4081}" FolderPath="startsWith\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.startsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD runStartsWith : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('startsWith')));

THIS^.testStartsWith(
	stringToTest := '',
	expectedString := ''
);
THIS^.testStartsWith(
	stringToTest := 'not empty',
	expectedString := ''
);
THIS^.testStartsWith(
	stringToTest := '',
	expectedString := 'not empty'
);
THIS^.testStartsWith(
	stringToTest := 'not empty',
	expectedString := 'not empty'
);
THIS^.testStartsWith(
	stringToTest := '{|}~',
	expectedString := '3649213469328'
);
THIS^.testStartsWith(
	stringToTest := '1one!',
	expectedString := '1'
);
THIS^.testStartsWith(
	stringToTest := '1one!',
	expectedString := 'one'
);
THIS^.testStartsWith(
	stringToTest := '1one!',
	expectedString := '!'
);
THIS^.testStartsWith(
	stringToTest := '$40$n$t$$$"$'',
	expectedString := '$n$t'
);
THIS^.testStartsWith(
	stringToTest := '$n$t$40$$$"$'',
	expectedString := '$n$t'
);
THIS^.testStartsWith(
	stringToTest := 'frontmiddleback',
	expectedString := 'front'
);
THIS^.testStartsWith(
	stringToTest := 'frontmiddleback',
	expectedString := 'frontmiddlebackfront'
);
THIS^.testStartsWith(
	stringToTest := 'backfrontmiddle',
	expectedString := 'backmiddle'
);
THIS^.testStartsWith(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y'
);
THIS^.testStartsWith(
	stringToTest := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)y',
	expectedString := 'J;%_iTxQSk?6GfWewt}yMKh1)VXqPA@P1YQ:{EAg:8VJ,/FM;j)xJ[[AvYp/}}SzEgtfYS,1K0.5VtA+VJrB(p#55h2z##mw#F)Y@P6Jz9G@6vb=x#E!cYk(Svr@S*KiPJr1VZ6AjrNback4G=vBJd.E:=,k3!wmuGDe#ZKMD#Vx%?M_0&L0#vT]J,+)ZvU{w%8X0=:XzthmT0VG0QrwpXXCWpFxu6[b!c.BunYYfLQi.,?ut?-{jrC1phTHL)x'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i), ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β)',
	expectedString := UTF8#'∮ E⋅da = Q,  n → ∞'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ⊂ ℚ ⊂ ℝ ⊂ ℂ'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, R = 4.7 kΩ, ⌀ 200 mm'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ, ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (A ⇔ B), 2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm',
	expectedString := UTF8#'ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ⊥'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]ˈnæʃənəl fəˈnɛtık ',
	expectedString := UTF8#'ði ıntəˈnæʃənəl fəˈnɛtık'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €',
	expectedString := UTF8#'‚‘„“‘’“We’ve been here”´` †, ‡, ‰, •, 3–4, —, −5/+5, ™, …, 1lI|, 0OD, 8B, €'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'Σὲ γνωρίζω ἀπὸ τὴν κόψη τοῦ σπαθιοῦ τὴν τρομερή,',
	expectedString := UTF8#'τὴν κόψη τοῦ σπαθ'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო კონფერენციაზე დასასწრებად',
	expectedString := UTF8#'გთხოვთ ახლავე გაიაროთ რეგისტრაცია'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'Зарегистрируйтесь сейчас на Десятую Международную Конференцию по Unicode, которая состоится 10-12 марта 1997 года в',
	expectedString := UTF8#'Международную Конференцию по Unicode, которая'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่',
	expectedString := UTF8#'๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช ' 
);
THIS^.testStartsWith(
	stringToTest := UTF8#' ሰማይ አይታረስ ንጉሥ አይከሰስ። ብላ ካለኝ እንደአባቴ በቆመጠኝ።',
	expectedString := UTF8#'አይታረስ ንጉሥ አይከሰስ። በቆመጠኝ።'
);
THIS^.testStartsWith(
	stringToTest := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ',
	expectedString := UTF8#' ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞',
	expectedString := UTF8#'⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙'
);
THIS^.testStartsWith(
	stringToTest := UTF8#'╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳',
	expectedString := UTF8#'╔══╦══╗  ┌──┬──┐'
);

THIS^.testStartsWithIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'UPPER'
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'lower'
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := 'UPPERCASE',
	expectedString := 'upper'
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := 'lowercase',
	expectedString := 'LOWER'
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := 'lower',
	expectedString := 'UPPER'
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := UTF8#'⌷←⍳→⍴∆∇⊃‾⍎⍕⌈UPPERCASE',
	expectedString := UTF8#'⌷←⍳→⍴∆∇⊃‾⍎⍕⌈upper'
);
THIS^.testStartsWithIgnoreCase(
	stringToTest := UTF8#'⌷←⍳→⍴∆∇⊃‾⍎⍕⌈UPPERCASE',
	expectedString := UTF8#'⌷←⍳→⍴∆∇⊃‾⍎upper'
);

THIS^.testStartsWithTrim(
	stringToTest := '$tfrontmiddleback',
	expectedString := 'front'
);
THIS^.testStartsWithTrim(
	stringToTest := 'frontmiddleback',
	expectedString := '$tfront'
);
THIS^.testStartsWithTrim(
	stringToTest := '$20frontmiddleback',
	expectedString := 'front'
);
THIS^.testStartsWithTrim(
	stringToTest := 'frontmiddleback',
	expectedString := '$20front'
);
THIS^.testStartsWithTrim(
	stringToTest := '$t$n$r$p$lfrontmiddleback',
	expectedString := '$20$r$t$n$l$pfront'
);
THIS^.testStartsWithTrim(
	stringToTest := '$t$n$r$p$lfrontmiddleback',
	expectedString := '$20$t$n$r$p$lfront'
);
THIS^.testStartsWithTrim(
	stringToTest := UTF8#'$t$n$r$p$l⌷←⍳→⍴∆∇⊃‾⍎⍕⌈frontmiddleback$t$n$r$p$l',
	expectedString := UTF8#'⌷←⍳→⍴∆∇⊃‾⍎⍕⌈front'
);
THIS^.testStartsWithTrim(
	stringToTest := UTF8#'$t$n$r$p$l⌷←⍳→⍴∆∇⊃‾⍎⍕⌈frontmiddleback$t$n$r$p$l',
	expectedString := UTF8#'⌷←⍳→⍴∆∇⊃‾⍎⍕front⌈'
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testContains" Id="{6e8dee0e-4e0a-4582-ad7a-726ce543d0f0}" FolderPath="contains\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.contains``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testContains : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``searchString`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString := stringToTest;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString := expectedString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

CNM_UnicodeUtilities.GetUtf8StringLength(
			ADR(expectedString),
			characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(stringToTest),
			ADR(expectedString),
		) = 0
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.contains(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedStringToTest),
			ADR(normalizedExpectedString),
		) = 0
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.contains(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := FALSE, (* ignore case is tested in an other test *)
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="testContainsIgnoreCase" Id="{142defc8-a16c-4ce2-a8c1-a9b3e4be8cc2}" FolderPath="contains\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.contains``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testContainsIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``searchString`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:Tc2_System.T_MaxString;
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:Tc2_System.T_MaxString;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;

upperStringToTest := stringToTest;
upperExpectedString := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
			ADR(expectedString),
			characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(upperStringToTest),
			ADR(upperExpectedString)
		) = 0
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.contains(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedUpperStringToTest),
			ADR(normalizedUpperExpectedString),
		) = 0
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.contains(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testContainsNo" Id="{3cf32ecc-4dfe-47cc-808b-5da50e176ce3}" FolderPath="containsNo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.containsNo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testContainsNo : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``searchString`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;

CNM_UnicodeUtilities.GetUtf8StringLength(
			ADR(expectedString),
			characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(stringToTest),
			ADR(expectedString),
		) > 0
	) OR (
		expectedCharacterCount = 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.containsNo(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedStringToTest),
			ADR(normalizedExpectedString),
		) > 0
	) OR (
		expectedCharacterCount = 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.containsNo(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="testContainsNoIgnoreCase" Id="{d5de6553-258c-446f-9a9c-45ca10ef7473}" FolderPath="containsNo\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.containsNo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testContainsNoIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``searchString`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:Tc2_System.T_MaxString;
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:Tc2_System.T_MaxString;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;
upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
			ADR(expectedString),
			characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(upperStringToTest),
			ADR(upperExpectedString)
		) > 0
	) OR (
		expectedCharacterCount = 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' searchString is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.containsNo(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedUpperStringToTest),
			ADR(normalizedUpperExpectedString),
		) > 0
	) OR (
		expectedCharacterCount = 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.containsNo(
	stringToCheck := stringToTest,
	searchString := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testEndsWith" Id="{0ea10bc8-9b73-4db5-a24c-1bc50f2785b4}" FolderPath="endsWith\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.endsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testEndsWith : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``end`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* contains the rigth side of ``stringToCheck`` *)
	rightOfStringToCheck			:Tc2_System.T_MaxString;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;
rightOfStringToCheck := stringToTest;

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(expectedString),
	characterCount => expectedCharacterCount
);
CNM_UnicodeUtilities.RightOfUtf8String(ADR(rightOfStringToCheck), expectedCharacterCount);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(rightOfStringToCheck),
			ADR(expectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' end is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' end is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := FALSE,
	trim := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
rightOfStringToCheck := normalizedStringToTest;
CNM_UnicodeUtilities.RightOfUtf8String(ADR(rightOfStringToCheck), expectedCharacterCount);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(rightOfStringToCheck),
			ADR(normalizedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := FALSE,
	trim		:= FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testEndsWithIgnoreCase" Id="{f58f8648-41ac-402d-aa9b-ffc45f8ceca2}" FolderPath="endsWith\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.endsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testEndsWithIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``end`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:Tc2_System.T_MaxString;
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains the rigth side of ``stringToCheck`` *)
	rightOfStringToCheck			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:Tc2_System.T_MaxString;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;
upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(upperExpectedString),
	characterCount => expectedCharacterCount
);
rightOfStringToCheck := upperStringToTest;
CNM_UnicodeUtilities.RightOfUtf8String(ADR(rightOfStringToCheck), expectedCharacterCount);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(rightOfStringToCheck),
			ADR(upperExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' end is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' end is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := TRUE,
	trim := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperExpectedString));


CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
rightOfStringToCheck := normalizedUpperStringToTest;
CNM_UnicodeUtilities.RightOfUtf8String(ADR(rightOfStringToCheck), expectedCharacterCount);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(rightOfStringToCheck),
			ADR(normalizedUpperExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := TRUE,
	trim		:= FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testEndsWithTrim" Id="{c7d7c765-02dc-4e54-9e60-706c5a6b4d76}" FolderPath="endsWith\trim\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.endsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testEndsWithTrim : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``end`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains trimed ´´stringToTest´´ *)
	trimedStringToTest				:Tc2_System.T_MaxString;
	(* contains trimed ´´expectedString´´ *)
	trimedExpectedString			:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* right side of ``stringToCheck`` *)
	rightOfStringToCheck			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form trimed *)
	normalizedTrimedStringToTest	:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form trimed *)
	normalizedTrimedExpectedString	:Tc2_System.T_MaxString;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;
trimedStringToTest := stringToTest;
trimedExpectedString := expectedString;

// trim the right of both strings
CNM_UnicodeUtilities.TrimRightUtf8String(ADR(trimedStringToTest));
CNM_UnicodeUtilities.TrimRightUtf8String(ADR(trimedExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(trimedExpectedString),
	characterCount => expectedCharacterCount
);
rightOfStringToCheck := trimedStringToTest;
CNM_UnicodeUtilities.RightOfUtf8String(ADR(rightOfStringToCheck), expectedCharacterCount);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(rightOfStringToCheck),
			ADR(trimedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' end is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' end is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := FALSE,
	trim := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedTrimedStringToTest := normalizedStringToTest;
normalizedTrimedExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.TrimRightUtf8String(ADR(normalizedTrimedStringToTest));
CNM_UnicodeUtilities.TrimRightUtf8String(ADR(normalizedTrimedExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedTrimedExpectedString),
	characterCount => expectedCharacterCount
);
rightOfStringToCheck := normalizedTrimedStringToTest;
CNM_UnicodeUtilities.RightOfUtf8String(ADR(rightOfStringToCheck), expectedCharacterCount);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(rightOfStringToCheck),
			ADR(normalizedTrimedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.endsWith(
	stringToCheck := stringToTest,
	end := expectedString,
	ignoreCases := FALSE,
	trim		:= TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsEmpty" Id="{b365c378-b55a-4fb5-a3ad-27f526553c7e}" FolderPath="isEmpty\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isEmpty``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testisEmpty : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
stringToTestAsString := stringToTest;

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(stringToTest),
	characterCount => stringToTestCharacterCount
);
assertionIsWrong :=  stringToTestCharacterCount > 0;	

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
);

THIS^.assertorContainer.assertor.assert.strings.unicode.isEmpty(
	stringToCheck := stringToTest,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsEqualTo" Id="{c80adfeb-2026-4bf9-be02-13b431251379}" FolderPath="isEqualTo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testIsEqualTo : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``expected`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString 	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(stringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(expectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount <> expectedCharacterCount
	) OR (
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(stringToTest),
			ADR(expectedString)
		) <> 1
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' expected is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' expected is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.isEqualTo(
	stringToCheck := stringToTest,
	expected := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount <> expectedCharacterCount
	) OR (
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedStringToTest),
			ADR(normalizedExpectedString)
		) <> 1
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.isEqualTo(
	stringToCheck := stringToTest,
	expected := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsEqualToIgnoreCase" Id="{b5319a9a-1f0c-4b4d-bea0-b505d4a10ffd}" FolderPath="isEqualTo\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testIsEqualToIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``expected`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:Tc2_System.T_MaxString;
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:Tc2_System.T_MaxString;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;
upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(upperStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(upperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount <> expectedCharacterCount
	) OR (
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(upperStringToTest),
			ADR(upperExpectedString)
		) <> 1
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' expected is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' expected is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.isEqualTo(
	stringToCheck := stringToTest,
	expected := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedUpperStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount <> expectedCharacterCount
	) OR (
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedUpperStringToTest),
			ADR(normalizedUpperExpectedString)
		) <> 1
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.isEqualTo(
	stringToCheck := stringToTest,
	expected := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsNotEmpty" Id="{b797c9e4-bee2-4806-9b1f-a2f421ce7c55}" FolderPath="isNotEmpty\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isNotEmpty``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testIsNotEmpty : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest :Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
stringToTestAsString := stringToTest;

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(stringToTest),
	characterCount => stringToTestCharacterCount
);
assertionIsWrong :=  stringToTestCharacterCount = 0;

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
);


THIS^.assertorContainer.assertor.assert.strings.unicode.isNotEmpty(
	stringToCheck := stringToTest,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsNotEqualTo" Id="{049e607f-3d47-4f5a-b709-7db380ae65ed}" FolderPath="isNotEqualTo\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isNotEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testIsNotEqualTo : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``unexpected`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString :Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
	expected: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(stringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(expectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount = expectedCharacterCount
	) AND_THEN (
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(stringToTest),
			ADR(expectedString)
		) = 1
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' unexpected is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' unexpected is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF


messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.isNotEqualTo(
	stringToCheck := stringToTest,
	unexpected := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount = expectedCharacterCount
	) AND (
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedStringToTest),
			ADR(normalizedExpectedString)
		) = 1
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.isNotEqualTo(
	stringToCheck := stringToTest,
	unexpected := expectedString,
	ignoreCases := FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testIsNotEqualToIgnoreCase" Id="{66c78fe6-ee85-44bb-8eea-be536101f070}" FolderPath="isNotEqualTo\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.isNotEqualTo``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testIsNotEqualToIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``unexpected`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString :Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:Tc2_System.T_MaxString;
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:Tc2_System.T_MaxString;
	(* holds characterCount of ``stringToTest`` *)
	stringToTestCharacterCount		:UDINT;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;
upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(upperStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(upperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount = expectedCharacterCount
	) AND (
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(upperStringToTest),
			ADR(upperExpectedString)
		) = 1
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' unexpected is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' unexpected is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.isNotEqualTo(
	stringToCheck := stringToTest,
	unexpected := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedUpperStringToTest),
	characterCount => stringToTestCharacterCount
);
CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		stringToTestCharacterCount = expectedCharacterCount
	) AND (
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedUpperStringToTest),
			ADR(normalizedUpperExpectedString)
		) = 1
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.isNotEqualTo(
	stringToCheck := stringToTest,
	unexpected := expectedString,
	ignoreCases := TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testLengthIsBetween" Id="{a867847f-7e9e-4262-bdee-f317c48d59d6}" FolderPath="lengthIsBetween\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsBetween``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testLengthIsBetween : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 			:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``maxLength`` *)
	maxLength 				:UDINT;
	(* for the test it's the parameter ``minLength`` *)
	minLength 				:UDINT;
	(* UnicodeStringLengthUnit the input is tested for *)
	stringLengthUnit		:CNM_AssertionInterfaces.UnicodeStringLengthUnit;
	(* contains ``stringToTest`` in only ascii charachters for test output *)
	stringToTestPrintable 	:Tc2_System.T_MaxString := '';
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds string with current ´´stringLengthUnit´´ for the test message*)
	currentStringLengthUnit 		:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* length of current string to check in bytes *)
	stringToTestByteCount			:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount		:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength 				:UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	{attribute 'TcEncoding' := 'UTF-8'}
	normalizedStringToTest 			:Tc2_System.T_MaxString;
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth 				:DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters	:UDINT := 0;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
stringToTestAsString := stringToTest;

CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		LEN(stringToTestPrintable) <> 0
) THEN
	stringToTestAsString := stringToTestPrintable;
END_IF

CASE stringLengthUnit OF
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES:
	currentStringLengthUnit := 'BYTES';
	
	assertionIsWrong := ((stringToTestByteCount < minLength) OR ( stringToTestByteCount > maxLength ));
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS:	
	currentStringLengthUnit := 'CHARACTERS';
	THIS^.assertorContainer.resetAssertor();
	
	assertionIsWrong := ((
			stringToTestCodePointCount < minLength
		) OR (
			stringToTestCodePointCount > maxLength
		)
	);
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	   messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD:	
	currentStringLengthUnit := 'NFD';
	THIS^.assertorContainer.resetAssertor();
	
	CNM_UnicodeUtilities.NormalizeUtf8String(
		utf8StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf8StringLength(
		stringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := ((
			stringToTestCodePointCount < minLength
		) OR (
			stringToTestCodePointCount > maxLength
		)
	);
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC:	
	currentStringLengthUnit := 'NFC';
	THIS^.assertorContainer.resetAssertor();
	
	CNM_UnicodeUtilities.NormalizeUtf8String(
		utf8StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf8StringLength(
		stringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := ((
			stringToTestCodePointCount < minLength
		) OR (
			stringToTestCodePointCount > maxLength
		)
	);
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS:	
	currentStringLengthUnit := 'VISIBLE_CHARACTERS';
	THIS^.assertorContainer.resetAssertor();
	
	assertionIsWrong := ((
			stringToTestVisibleCharacters < minLength
		) OR (
			stringToTestVisibleCharacters > maxLength
		)
	);
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH:	
	currentStringLengthUnit := 'WIDTH';
	THIS^.assertorContainer.resetAssertor();
	
	assertionIsWrong := ((
			TO_UDINT(stringToTestWidth) < minLength
		) OR (
			TO_UDINT(stringToTestWidth) > maxLength
		)
	);
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with maxLength %u and minLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(maxLength),
		arg3 := THIS^.AnyToArg(minLength),
		arg4 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsBetween(
		stringToCheck := stringToTest,
		maxLength := maxLength,
		minLength := minLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testLengthIsExact" Id="{3def4d03-8129-47f7-8619-5854024c911c}" FolderPath="lengthIsExact\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsExact``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testLengthIsExact : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 			:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``expectedLength`` *)
	expectedLength			:UDINT;
	(* UnicodeStringLengthUnit the input is tested for *)
	stringLengthUnit		:CNM_AssertionInterfaces.UnicodeStringLengthUnit;
	(* contains ``stringToTest`` in only ascii charachters for test output *)
	stringToTestPrintable	:Tc2_System.T_MaxString := '';
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds string with current ´´stringLengthUnit´´ for the test message*)
	currentStringLengthUnit 		:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* length of current string to check in bytes *)
	stringToTestByteCount			:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount		:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength 				:UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	{attribute 'TcEncoding' := 'UTF-8'}
	normalizedStringToTest 			:Tc2_System.T_MaxString;
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth 				:DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters	:UDINT := 0;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
stringToTestAsString := stringToTest;

CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		LEN(stringToTestPrintable) <> 0
) THEN
	stringToTestAsString := stringToTestPrintable;
END_IF

CASE stringLengthUnit OF

CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES:
	currentStringLengthUnit := 'BYTES';
	
	assertionIsWrong := stringToTestByteCount <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS:	
	currentStringLengthUnit := 'CHARACTERS';
	
	assertionIsWrong := stringToTestCodePointCount <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD:	
	currentStringLengthUnit := 'NFD';
	
	CNM_UnicodeUtilities.NormalizeUtf8String(
		utf8StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf8StringLength(
		stringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC:	
	currentStringLengthUnit := 'NFC';
	
	CNM_UnicodeUtilities.NormalizeUtf8String(
		utf8StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf8StringLength(
		stringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS:	
	currentStringLengthUnit := 'VISIBLE_CHARACTERS';
	
	assertionIsWrong := stringToTestVisibleCharacters <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH:	
	currentStringLengthUnit := 'WIDTH';
	
	assertionIsWrong := TO_UDINT(stringToTestWidth) <> expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsExact(
		stringToCheck := stringToTest,
		expectedLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testLengthIsMax" Id="{b8ccdd63-f4d5-4065-adfc-01691bc302a2}" FolderPath="lengthIsMax\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsMax``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testLengthIsMax : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 			:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``maxLength`` *)
	expectedLength			:UDINT;
	(* UnicodeStringLengthUnit the input is tested for *)
	stringLengthUnit		:CNM_AssertionInterfaces.UnicodeStringLengthUnit;
	(* contains ``stringToTest`` in only ascii charachters for test output *)
	stringToTestPrintable	:Tc2_System.T_MaxString := '';
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds string with current ´´stringLengthUnit´´ for the test message*)
	currentStringLengthUnit 		:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* length of current string to check in bytes *)
	stringToTestByteCount			:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount		:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength 				:UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	{attribute 'TcEncoding' := 'UTF-8'}
	normalizedStringToTest 			:Tc2_System.T_MaxString;
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth 				:DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters	:UDINT := 0;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
stringToTestAsString := stringToTest;

CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		LEN(stringToTestPrintable) <> 0
) THEN
	stringToTestAsString := stringToTestPrintable;
END_IF

CASE stringLengthUnit OF
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES:
	currentStringLengthUnit := 'BYTES';
	
	assertionIsWrong := stringToTestByteCount > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS:	
	currentStringLengthUnit := 'CHARACTERS';
	THIS^.assertorContainer.resetAssertor();
	
	assertionIsWrong := stringToTestCodePointCount > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD:	
	currentStringLengthUnit := 'NFD';
	THIS^.assertorContainer.resetAssertor();
	
	CNM_UnicodeUtilities.NormalizeUtf8String(
		utf8StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf8StringLength(
		stringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC:	
	currentStringLengthUnit := 'NFC';
	THIS^.assertorContainer.resetAssertor();
	
	CNM_UnicodeUtilities.NormalizeUtf8String(
		utf8StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf8StringLength(
		stringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS:	
	currentStringLengthUnit := 'VISIBLE_CHARACTERS';
	THIS^.assertorContainer.resetAssertor();
	
	assertionIsWrong := stringToTestVisibleCharacters > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH:	
	currentStringLengthUnit := 'WIDTH';
	THIS^.assertorContainer.resetAssertor();
	
	assertionIsWrong := TO_UDINT(stringToTestWidth) > expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMax(
		stringToCheck := stringToTest,
		maxLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);

	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);

END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testLengthIsMin" Id="{71272327-ab81-46f5-ad04-50fde3f5f841}" FolderPath="lengthIsMin\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.lengthIsMin``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testLengthIsMin : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 			:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``minLength`` *)
	expectedLength 			:UDINT;
	(* UnicodeStringLengthUnit the input is tested for *)
	stringLengthUnit		:CNM_AssertionInterfaces.UnicodeStringLengthUnit;
	(* contains ``stringToTest`` in only ascii charachters for test output *)
	stringToTestPrintable	:Tc2_System.T_MaxString := '';
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* holds string with current ´´stringLengthUnit´´ for the test message*)
	currentStringLengthUnit 		:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* length of current string to check in bytes *)
	stringToTestByteCount			:UDINT;
	(* length of current string to check in characters *)
	stringToTestCodePointCount		:UDINT;
	(* length of ´´stringToCheck´´ *)
	normalizedLength 				:UDINT;
	(* holds the normalized ´´stringToCheck´´ *)
	{attribute 'TcEncoding' := 'UTF-8'}
	normalizedStringToTest 			:Tc2_System.T_MaxString;
	(* width of ´´stringToCheck´´ *)
	stringToTestWidth 				:DINT;
	(* visible characters of ´´stringToCheck´´ *)
	stringToTestVisibleCharacters	:UDINT := 0;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
stringToTestAsString := stringToTest;

CNM_UnicodeUtilities.GetUtf8StringLength(ADR(stringToTest), byteCount => stringToTestByteCount, characterCount => stringToTestCodePointCount,);
CNM_UnicodeUtilities.GetUtf8StringWidth(ADR(stringToTest), visibleCharacters => stringToTestVisibleCharacters, width => stringToTestWidth);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		LEN(stringToTestPrintable) <> 0
) THEN
	stringToTestAsString := stringToTestPrintable;
END_IF

CASE stringLengthUnit OF
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES:
	currentStringLengthUnit := 'BYTES';
	
	assertionIsWrong := stringToTestByteCount < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.BYTES,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS:	
	currentStringLengthUnit := 'CHARACTERS';
	THIS^.assertorContainer.resetAssertor();
	
	assertionIsWrong := stringToTestCodePointCount < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD:	
	currentStringLengthUnit := 'NFD';
	THIS^.assertorContainer.resetAssertor();
	
	CNM_UnicodeUtilities.NormalizeUtf8String(
		utf8StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf8StringLength(
		stringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFD,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC:	
	currentStringLengthUnit := 'NFC';
	THIS^.assertorContainer.resetAssertor();
	
	CNM_UnicodeUtilities.NormalizeUtf8String(
		utf8StringBuffer := ADR(stringToTest),
		normalForm := CNM_UnicodeUtilities.NormalizationForm.NFC,
		normalizedStringBuffer := ADR(normalizedStringToTest),
		bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
		normalizedStringLength => normalizedLength
	);
	CNM_UnicodeUtilities.GetUtf8StringLength(
		stringAddress := ADR(normalizedStringToTest),
		characterCount => stringToTestCodePointCount
	);
		
	assertionIsWrong := stringToTestCodePointCount < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.CHARACTERS_NFC,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS:	
	currentStringLengthUnit := 'VISIBLE_CHARACTERS';
	THIS^.assertorContainer.resetAssertor();
	
	assertionIsWrong := stringToTestVisibleCharacters < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.VISIBLE_CHARACTERS,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH:	
	currentStringLengthUnit := 'WIDTH';
	THIS^.assertorContainer.resetAssertor();
	
	assertionIsWrong := TO_UDINT(stringToTestWidth) < expectedLength;
	
	message := SEL(
		assertionIsWrong,
		'stringToCheck is $'%s$' with expectedLength %u assertion must be TRUE  (%S)', 
		'stringToCheck is $'%s$' with expectedLength %u assertion must be FALSE  (%S)'
	);
	
	messageStringBuilder(
		sFormat := message,
		arg1 := THIS^.AnyToArg(stringToTestAsString),
		arg2 := THIS^.AnyToArg(expectedLength),
		arg3 := THIS^.AnyToArg(currentStringLengthUnit)
	);
	
	THIS^.assertorContainer.assertor.assert.strings.unicode.lengthIsMin(
		stringToCheck := stringToTest,
		minLength := expectedLength,
		stringLengthUnit := CNM_AssertionInterfaces.UnicodeStringLengthUnit.WIDTH,
		message			:= ''
	);
	
	THIS^.AssertEquals_BOOL(
		Expected 	:= assertionIsWrong,
		Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
		Message 	:= messageStringBuilder.sOut
	);
	
	THIS^.AssertEquals_STRING(
		Expected 	:= stringToTestBeforeAssertion,
		Actual 		:= stringToTest,
		Message 	:= 'the assertion changed $'stringToTest$''
	);
	
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testStartsWith" Id="{2b64efc1-a70a-4a76-ac9a-4969bb4aa8d1}" FolderPath="startsWith\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.startsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testStartsWith : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``end`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString 	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(expectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(stringToTest),
			ADR(expectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' start is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' start is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := FALSE,
	trim := FALSE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedStringToTest),
			ADR(normalizedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := FALSE,
	trim		:= FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testStartsWithIgnoreCase" Id="{20a9c6c6-2730-4e3e-af20-28b73f679239}" FolderPath="startsWith\ignoreCase\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.startsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testStartsWithIgnoreCase : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``end`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains ´´stringToTest´´ in upper case *)
	upperStringToTest				:Tc2_System.T_MaxString;
	(* contains ´´expectedString´´ in upper case *)
	upperExpectedString				:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form in upper case*)
	normalizedUpperStringToTest		:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form in upper case*)
	normalizedUpperExpectedString	:Tc2_System.T_MaxString;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;
upperStringToTest := stringToTest;
upperExpectedString := expectedString;

// both Strings to upper case
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(upperExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(upperExpectedString),
	characterCount => expectedCharacterCount
);	
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(upperStringToTest),
			ADR(upperExpectedString)
		) <> 1 
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' start is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' start is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := TRUE,
	trim := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedUpperStringToTest := normalizedStringToTest;
normalizedUpperExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperStringToTest));
CNM_UnicodeUtilities.UpperCaseUtf8(ADR(normalizedUpperExpectedString));


CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedUpperExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedUpperStringToTest),
			ADR(normalizedUpperExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := TRUE,
	trim		:= FALSE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="testStartsWithTrim" Id="{85d3aea6-a50e-4601-8638-6ed914d8dc77}" FolderPath="startsWith\trim\">
      <Declaration><![CDATA[(*
short summary
==================
This test method tests ``assert.string.unicode.startsWith``
method of CNM_AssertionInterfaces library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)


METHOD testStartsWithTrim : BOOL
VAR_INPUT
	(* for the test it's the parameter ``stringToCheck`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	stringToTest 	:Tc2_System.T_MaxString;
	(* for the test it's the parameter ``end`` *)
	{attribute 'TcEncoding' := 'UTF-8'}
	expectedString 	:Tc2_System.T_MaxString;
END_VAR
VAR 
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong				:BOOL;
	(* contains the format string for the test message *)
	message							:Tc2_System.T_MaxString;
	(* contains trimed ´´stringToTest´´ *)
	trimedStringToTest				:Tc2_System.T_MaxString;
	(* contains trimed ´´expectedString´´ *)
	trimedExpectedString			:Tc2_System.T_MaxString;
	(* used for placeholder string if stringToTest can't be printed *)
	stringToTestAsString 			:Tc2_System.T_MaxString;
	(* used for placeholder string if expectedString can't be printed *)
	expectedStringAsString 			:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form *)
	normalizedStringToTest			:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form *)
	normalizedExpectedString		:Tc2_System.T_MaxString;
	(* contains stringToTest in normalized form trimed *)
	normalizedTrimedStringToTest	:Tc2_System.T_MaxString;
	(* contains expectedString in normalized form trimed *)
	normalizedTrimedExpectedString	:Tc2_System.T_MaxString;
	(* holds characterCount of ``expectedString`` *)
	expectedCharacterCount			:UDINT;
	(* TwinCAT printf with the test message *)
	messageStringBuilder			:Tc2_Utilities.FB_FormatString;
	(* hold stringToCheck before assertion *)
	stringToTestBeforeAssertion		:Tc2_System.T_MaxString;
	(* hold expectedString before assertion *)
	expectedStringBeforeAssertion	:Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

stringToTestBeforeAssertion := stringToTest;
expectedStringBeforeAssertion := expectedString;
stringToTestAsString := stringToTest;
expectedStringAsString := expectedString;
trimedStringToTest := stringToTest;
trimedExpectedString := expectedString;

// trim the left of both strings
CNM_UnicodeUtilities.TrimLeftUtf8String(ADR(trimedStringToTest));
CNM_UnicodeUtilities.TrimLeftUtf8String(ADR(trimedExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(trimedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(trimedStringToTest),
			ADR(trimedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

message := SEL(
	assertionIsWrong,
	'stringToCheck is $'%s$' start is $'%s$' assertion must be TRUE', 
	'stringToCheck is $'%s$' start is $'%s$' assertion must be FALSE'
);

IF (
		Tc2_Standard.LEN(stringToTest) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	stringToTestAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF
IF (
		Tc2_Standard.LEN(expectedString) = TO_UINT(Tc2_System.MAX_STRING_LENGTH)
) THEN
	expectedStringAsString := 'String with Tc2_System.MAX_STRING_LENGTH characters';
END_IF

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(stringToTestAsString),
	arg2 := THIS^.AnyToArg(expectedStringAsString)
);


THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := FALSE,
	trim := TRUE,
	normalizeStrings := FALSE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);

THIS^.assertorContainer.resetAssertor();

CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(stringToTest),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedStringToTest),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);
CNM_UnicodeUtilities.NormalizeUtf8String(
	utf8StringBuffer := ADR(expectedString),
	bufferSize := Tc2_System.MAX_STRING_LENGTH + 1,
	normalizedStringBuffer := ADR(normalizedExpectedString),
	normalForm := CNM_UnicodeUtilities.NormalizationForm.NFD
);

normalizedTrimedStringToTest := normalizedStringToTest;
normalizedTrimedExpectedString := normalizedExpectedString;
CNM_UnicodeUtilities.TrimLeftUtf8String(ADR(normalizedTrimedStringToTest));
CNM_UnicodeUtilities.TrimLeftUtf8String(ADR(normalizedTrimedExpectedString));

CNM_UnicodeUtilities.GetUtf8StringLength(
	ADR(normalizedTrimedExpectedString),
	characterCount => expectedCharacterCount
);
assertionIsWrong := ((
		CNM_UnicodeUtilities.FindInUtf8String(
			ADR(normalizedTrimedStringToTest),
			ADR(normalizedTrimedExpectedString),
		) <> 1
	) AND (
		expectedCharacterCount <> 0
	)
);

THIS^.assertorContainer.assertor.assert.strings.unicode.startsWith(
	stringToCheck := stringToTest,
	start := expectedString,
	ignoreCases := FALSE,
	trim		:= TRUE,
	normalizeStrings := TRUE,
	message			:= ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

THIS^.AssertEquals_STRING(
	Expected 	:= stringToTestBeforeAssertion,
	Actual 		:= stringToTest,
	Message 	:= 'the assertion changed $'stringToTest$''
);

THIS^.AssertEquals_STRING(
	Expected 	:= expectedStringBeforeAssertion,
	Actual 		:= expectedString,
	Message 	:= 'the assertion changed $'expectedString$''
);
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="UnicodeUtf8StringAssertionTests">
      <LineId Id="1" Count="11" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.getTestNameFor">
      <LineId Id="1" Count="1" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runContains">
      <LineId Id="1" Count="77" />
      <LineId Id="113" Count="2" />
      <LineId Id="112" Count="0" />
      <LineId Id="116" Count="2" />
      <LineId Id="79" Count="0" />
      <LineId Id="120" Count="2" />
      <LineId Id="119" Count="0" />
      <LineId Id="124" Count="2" />
      <LineId Id="123" Count="0" />
      <LineId Id="128" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="130" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="134" Count="2" />
      <LineId Id="133" Count="0" />
      <LineId Id="138" Count="2" />
      <LineId Id="137" Count="0" />
      <LineId Id="142" Count="0" />
      <LineId Id="145" Count="1" />
      <LineId Id="144" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="150" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="80" Count="27" />
      <LineId Id="110" Count="1" />
      <LineId Id="161" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runContainsNo">
      <LineId Id="1" Count="0" />
      <LineId Id="10" Count="56" />
      <LineId Id="92" Count="37" />
      <LineId Id="131" Count="17" />
      <LineId Id="91" Count="0" />
      <LineId Id="67" Count="20" />
      <LineId Id="150" Count="6" />
      <LineId Id="149" Count="0" />
      <LineId Id="89" Count="1" />
      <LineId Id="157" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runEndsWith">
      <LineId Id="1" Count="0" />
      <LineId Id="219" Count="0" />
      <LineId Id="11" Count="59" />
      <LineId Id="121" Count="37" />
      <LineId Id="160" Count="17" />
      <LineId Id="120" Count="0" />
      <LineId Id="71" Count="20" />
      <LineId Id="179" Count="6" />
      <LineId Id="178" Count="0" />
      <LineId Id="92" Count="24" />
      <LineId Id="187" Count="2" />
      <LineId Id="186" Count="0" />
      <LineId Id="190" Count="3" />
      <LineId Id="118" Count="1" />
      <LineId Id="194" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runIsEmpty">
      <LineId Id="1" Count="31" />
      <LineId Id="39" Count="1" />
      <LineId Id="42" Count="2" />
      <LineId Id="46" Count="0" />
      <LineId Id="55" Count="1" />
      <LineId Id="58" Count="2" />
      <LineId Id="62" Count="2" />
      <LineId Id="66" Count="2" />
      <LineId Id="70" Count="2" />
      <LineId Id="74" Count="2" />
      <LineId Id="79" Count="2" />
      <LineId Id="83" Count="2" />
      <LineId Id="87" Count="3" />
      <LineId Id="92" Count="2" />
      <LineId Id="38" Count="0" />
      <LineId Id="34" Count="1" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runIsEqualTo">
      <LineId Id="1" Count="62" />
      <LineId Id="85" Count="11" />
      <LineId Id="101" Count="21" />
      <LineId Id="124" Count="17" />
      <LineId Id="84" Count="0" />
      <LineId Id="64" Count="16" />
      <LineId Id="144" Count="6" />
      <LineId Id="143" Count="0" />
      <LineId Id="82" Count="1" />
      <LineId Id="151" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runIsNotEmpty">
      <LineId Id="1" Count="31" />
      <LineId Id="39" Count="22" />
      <LineId Id="63" Count="12" />
      <LineId Id="38" Count="0" />
      <LineId Id="34" Count="1" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runIsNotEqualTo">
      <LineId Id="1" Count="62" />
      <LineId Id="85" Count="33" />
      <LineId Id="120" Count="0" />
      <LineId Id="122" Count="16" />
      <LineId Id="84" Count="0" />
      <LineId Id="64" Count="16" />
      <LineId Id="139" Count="6" />
      <LineId Id="81" Count="2" />
      <LineId Id="146" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runLengthIsBetween">
      <LineId Id="1" Count="0" />
      <LineId Id="181" Count="0" />
      <LineId Id="664" Count="82" />
      <LineId Id="429" Count="7" />
      <LineId Id="747" Count="0" />
      <LineId Id="437" Count="5" />
      <LineId Id="748" Count="0" />
      <LineId Id="443" Count="5" />
      <LineId Id="749" Count="0" />
      <LineId Id="449" Count="5" />
      <LineId Id="750" Count="0" />
      <LineId Id="455" Count="5" />
      <LineId Id="751" Count="0" />
      <LineId Id="461" Count="9" />
      <LineId Id="752" Count="0" />
      <LineId Id="471" Count="2" />
      <LineId Id="480" Count="2" />
      <LineId Id="760" Count="0" />
      <LineId Id="483" Count="2" />
      <LineId Id="754" Count="5" />
      <LineId Id="753" Count="0" />
      <LineId Id="486" Count="2" />
      <LineId Id="761" Count="0" />
      <LineId Id="489" Count="5" />
      <LineId Id="762" Count="0" />
      <LineId Id="495" Count="16" />
      <LineId Id="763" Count="0" />
      <LineId Id="512" Count="16" />
      <LineId Id="764" Count="0" />
      <LineId Id="529" Count="2" />
      <LineId Id="779" Count="5" />
      <LineId Id="778" Count="0" />
      <LineId Id="532" Count="6" />
      <LineId Id="765" Count="0" />
      <LineId Id="539" Count="5" />
      <LineId Id="766" Count="0" />
      <LineId Id="545" Count="5" />
      <LineId Id="767" Count="0" />
      <LineId Id="551" Count="5" />
      <LineId Id="768" Count="0" />
      <LineId Id="557" Count="16" />
      <LineId Id="769" Count="0" />
      <LineId Id="574" Count="16" />
      <LineId Id="770" Count="0" />
      <LineId Id="591" Count="2" />
      <LineId Id="786" Count="5" />
      <LineId Id="785" Count="0" />
      <LineId Id="594" Count="6" />
      <LineId Id="771" Count="0" />
      <LineId Id="601" Count="5" />
      <LineId Id="772" Count="0" />
      <LineId Id="607" Count="5" />
      <LineId Id="773" Count="0" />
      <LineId Id="613" Count="5" />
      <LineId Id="774" Count="0" />
      <LineId Id="619" Count="5" />
      <LineId Id="775" Count="0" />
      <LineId Id="625" Count="16" />
      <LineId Id="776" Count="0" />
      <LineId Id="642" Count="16" />
      <LineId Id="777" Count="0" />
      <LineId Id="659" Count="1" />
      <LineId Id="70" Count="0" />
      <LineId Id="358" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="359" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runLengthIsExact">
      <LineId Id="1" Count="1" />
      <LineId Id="283" Count="73" />
      <LineId Id="358" Count="33" />
      <LineId Id="393" Count="67" />
      <LineId Id="462" Count="61" />
      <LineId Id="525" Count="62" />
      <LineId Id="55" Count="2" />
      <LineId Id="282" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runLengthIsMax">
      <LineId Id="1" Count="1" />
      <LineId Id="277" Count="300" />
      <LineId Id="208" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="276" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runLengthIsMin">
      <LineId Id="1" Count="1" />
      <LineId Id="269" Count="300" />
      <LineId Id="59" Count="2" />
      <LineId Id="268" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.runStartsWith">
      <LineId Id="1" Count="61" />
      <LineId Id="115" Count="37" />
      <LineId Id="154" Count="17" />
      <LineId Id="114" Count="0" />
      <LineId Id="63" Count="20" />
      <LineId Id="173" Count="3" />
      <LineId Id="180" Count="2" />
      <LineId Id="172" Count="0" />
      <LineId Id="84" Count="24" />
      <LineId Id="184" Count="3" />
      <LineId Id="191" Count="2" />
      <LineId Id="183" Count="0" />
      <LineId Id="112" Count="1" />
      <LineId Id="194" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testContains">
      <LineId Id="1" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="62" Count="2" />
      <LineId Id="61" Count="0" />
      <LineId Id="3" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="47" Count="2" />
      <LineId Id="41" Count="0" />
      <LineId Id="44" Count="2" />
      <LineId Id="4" Count="4" />
      <LineId Id="115" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="50" Count="8" />
      <LineId Id="16" Count="12" />
      <LineId Id="67" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="31" Count="5" />
      <LineId Id="65" Count="0" />
      <LineId Id="68" Count="11" />
      <LineId Id="85" Count="27" />
      <LineId Id="66" Count="0" />
      <LineId Id="125" Count="14" />
      <LineId Id="113" Count="1" />
      <LineId Id="140" Count="0" />
      <LineId Id="116" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testContainsIgnoreCase">
      <LineId Id="1" Count="4" />
      <LineId Id="58" Count="3" />
      <LineId Id="6" Count="1" />
      <LineId Id="43" Count="0" />
      <LineId Id="51" Count="2" />
      <LineId Id="44" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="46" Count="1" />
      <LineId Id="8" Count="7" />
      <LineId Id="54" Count="1" />
      <LineId Id="16" Count="2" />
      <LineId Id="56" Count="1" />
      <LineId Id="19" Count="1" />
      <LineId Id="22" Count="11" />
      <LineId Id="110" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="36" Count="5" />
      <LineId Id="63" Count="17" />
      <LineId Id="82" Count="27" />
      <LineId Id="42" Count="0" />
      <LineId Id="139" Count="3" />
      <LineId Id="111" Count="27" />
      <LineId Id="143" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testContainsNo">
      <LineId Id="1" Count="1" />
      <LineId Id="58" Count="11" />
      <LineId Id="47" Count="0" />
      <LineId Id="4" Count="6" />
      <LineId Id="48" Count="8" />
      <LineId Id="16" Count="12" />
      <LineId Id="57" Count="0" />
      <LineId Id="29" Count="7" />
      <LineId Id="70" Count="0" />
      <LineId Id="111" Count="0" />
      <LineId Id="71" Count="39" />
      <LineId Id="37" Count="0" />
      <LineId Id="128" Count="12" />
      <LineId Id="112" Count="15" />
      <LineId Id="141" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testContainsNoIgnoreCase">
      <LineId Id="1" Count="2" />
      <LineId Id="62" Count="2" />
      <LineId Id="75" Count="11" />
      <LineId Id="51" Count="0" />
      <LineId Id="8" Count="6" />
      <LineId Id="52" Count="8" />
      <LineId Id="20" Count="12" />
      <LineId Id="61" Count="0" />
      <LineId Id="33" Count="7" />
      <LineId Id="132" Count="0" />
      <LineId Id="87" Count="44" />
      <LineId Id="41" Count="0" />
      <LineId Id="139" Count="25" />
      <LineId Id="133" Count="5" />
      <LineId Id="165" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testEndsWith">
      <LineId Id="131" Count="5" />
      <LineId Id="236" Count="0" />
      <LineId Id="137" Count="9" />
      <LineId Id="231" Count="0" />
      <LineId Id="147" Count="3" />
      <LineId Id="152" Count="34" />
      <LineId Id="232" Count="0" />
      <LineId Id="187" Count="16" />
      <LineId Id="205" Count="9" />
      <LineId Id="230" Count="0" />
      <LineId Id="215" Count="7" />
      <LineId Id="237" Count="0" />
      <LineId Id="223" Count="5" />
      <LineId Id="39" Count="0" />
      <LineId Id="229" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="107" Count="23" />
      <LineId Id="233" Count="2" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testEndsWithIgnoreCase">
      <LineId Id="149" Count="16" />
      <LineId Id="261" Count="0" />
      <LineId Id="166" Count="9" />
      <LineId Id="177" Count="31" />
      <LineId Id="259" Count="0" />
      <LineId Id="209" Count="33" />
      <LineId Id="258" Count="0" />
      <LineId Id="243" Count="9" />
      <LineId Id="262" Count="0" />
      <LineId Id="253" Count="4" />
      <LineId Id="136" Count="0" />
      <LineId Id="115" Count="20" />
      <LineId Id="260" Count="0" />
      <LineId Id="137" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testEndsWithTrim">
      <LineId Id="135" Count="3" />
      <LineId Id="242" Count="0" />
      <LineId Id="139" Count="12" />
      <LineId Id="256" Count="0" />
      <LineId Id="152" Count="8" />
      <LineId Id="162" Count="31" />
      <LineId Id="241" Count="0" />
      <LineId Id="194" Count="14" />
      <LineId Id="243" Count="0" />
      <LineId Id="209" Count="1" />
      <LineId Id="244" Count="0" />
      <LineId Id="211" Count="13" />
      <LineId Id="240" Count="0" />
      <LineId Id="225" Count="9" />
      <LineId Id="257" Count="0" />
      <LineId Id="235" Count="4" />
      <LineId Id="133" Count="0" />
      <LineId Id="114" Count="2" />
      <LineId Id="118" Count="14" />
      <LineId Id="245" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="246" Count="9" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testIsEmpty">
      <LineId Id="1" Count="0" />
      <LineId Id="38" Count="3" />
      <LineId Id="2" Count="1" />
      <LineId Id="5" Count="6" />
      <LineId Id="33" Count="4" />
      <LineId Id="15" Count="4" />
      <LineId Id="21" Count="11" />
      <LineId Id="47" Count="2" />
      <LineId Id="42" Count="4" />
      <LineId Id="50" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testIsEqualTo">
      <LineId Id="1" Count="1" />
      <LineId Id="58" Count="15" />
      <LineId Id="47" Count="0" />
      <LineId Id="4" Count="6" />
      <LineId Id="48" Count="8" />
      <LineId Id="16" Count="12" />
      <LineId Id="57" Count="0" />
      <LineId Id="29" Count="7" />
      <LineId Id="125" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="75" Count="11" />
      <LineId Id="92" Count="31" />
      <LineId Id="37" Count="0" />
      <LineId Id="135" Count="18" />
      <LineId Id="126" Count="8" />
      <LineId Id="154" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testIsEqualToIgnoreCase">
      <LineId Id="1" Count="4" />
      <LineId Id="69" Count="3" />
      <LineId Id="65" Count="3" />
      <LineId Id="6" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="44" Count="1" />
      <LineId Id="73" Count="2" />
      <LineId Id="49" Count="2" />
      <LineId Id="8" Count="6" />
      <LineId Id="52" Count="8" />
      <LineId Id="20" Count="12" />
      <LineId Id="61" Count="0" />
      <LineId Id="33" Count="7" />
      <LineId Id="76" Count="0" />
      <LineId Id="143" Count="0" />
      <LineId Id="78" Count="16" />
      <LineId Id="96" Count="0" />
      <LineId Id="127" Count="15" />
      <LineId Id="111" Count="5" />
      <LineId Id="118" Count="8" />
      <LineId Id="77" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="148" Count="25" />
      <LineId Id="144" Count="3" />
      <LineId Id="174" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testIsNotEmpty">
      <LineId Id="1" Count="1" />
      <LineId Id="38" Count="3" />
      <LineId Id="3" Count="0" />
      <LineId Id="5" Count="6" />
      <LineId Id="33" Count="4" />
      <LineId Id="15" Count="17" />
      <LineId Id="48" Count="1" />
      <LineId Id="42" Count="5" />
      <LineId Id="50" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testIsNotEqualTo">
      <LineId Id="1" Count="1" />
      <LineId Id="59" Count="15" />
      <LineId Id="48" Count="0" />
      <LineId Id="4" Count="6" />
      <LineId Id="49" Count="8" />
      <LineId Id="16" Count="13" />
      <LineId Id="58" Count="0" />
      <LineId Id="30" Count="7" />
      <LineId Id="120" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="76" Count="42" />
      <LineId Id="75" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="137" Count="12" />
      <LineId Id="121" Count="15" />
      <LineId Id="150" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testIsNotEqualToIgnoreCase">
      <LineId Id="1" Count="5" />
      <LineId Id="62" Count="15" />
      <LineId Id="51" Count="0" />
      <LineId Id="8" Count="6" />
      <LineId Id="52" Count="8" />
      <LineId Id="20" Count="12" />
      <LineId Id="61" Count="0" />
      <LineId Id="33" Count="7" />
      <LineId Id="128" Count="0" />
      <LineId Id="78" Count="49" />
      <LineId Id="41" Count="0" />
      <LineId Id="147" Count="12" />
      <LineId Id="129" Count="17" />
      <LineId Id="160" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testLengthIsBetween">
      <LineId Id="294" Count="3" />
      <LineId Id="304" Count="1" />
      <LineId Id="584" Count="1" />
      <LineId Id="306" Count="1" />
      <LineId Id="515" Count="0" />
      <LineId Id="586" Count="1" />
      <LineId Id="516" Count="1" />
      <LineId Id="500" Count="0" />
      <LineId Id="315" Count="0" />
      <LineId Id="588" Count="0" />
      <LineId Id="591" Count="0" />
      <LineId Id="498" Count="0" />
      <LineId Id="316" Count="1" />
      <LineId Id="519" Count="4" />
      <LineId Id="518" Count="0" />
      <LineId Id="442" Count="0" />
      <LineId Id="444" Count="5" />
      <LineId Id="443" Count="0" />
      <LineId Id="318" Count="14" />
      <LineId Id="501" Count="0" />
      <LineId Id="499" Count="0" />
      <LineId Id="510" Count="0" />
      <LineId Id="333" Count="1" />
      <LineId Id="559" Count="4" />
      <LineId Id="524" Count="0" />
      <LineId Id="526" Count="3" />
      <LineId Id="525" Count="0" />
      <LineId Id="468" Count="0" />
      <LineId Id="470" Count="5" />
      <LineId Id="469" Count="0" />
      <LineId Id="335" Count="13" />
      <LineId Id="502" Count="1" />
      <LineId Id="349" Count="0" />
      <LineId Id="511" Count="0" />
      <LineId Id="350" Count="13" />
      <LineId Id="564" Count="4" />
      <LineId Id="530" Count="0" />
      <LineId Id="532" Count="3" />
      <LineId Id="531" Count="0" />
      <LineId Id="458" Count="0" />
      <LineId Id="460" Count="5" />
      <LineId Id="459" Count="0" />
      <LineId Id="364" Count="13" />
      <LineId Id="504" Count="1" />
      <LineId Id="378" Count="0" />
      <LineId Id="512" Count="0" />
      <LineId Id="379" Count="13" />
      <LineId Id="569" Count="4" />
      <LineId Id="536" Count="0" />
      <LineId Id="538" Count="3" />
      <LineId Id="537" Count="0" />
      <LineId Id="466" Count="0" />
      <LineId Id="476" Count="5" />
      <LineId Id="467" Count="0" />
      <LineId Id="393" Count="14" />
      <LineId Id="506" Count="1" />
      <LineId Id="513" Count="0" />
      <LineId Id="408" Count="1" />
      <LineId Id="574" Count="4" />
      <LineId Id="542" Count="0" />
      <LineId Id="544" Count="3" />
      <LineId Id="543" Count="0" />
      <LineId Id="482" Count="0" />
      <LineId Id="484" Count="5" />
      <LineId Id="483" Count="0" />
      <LineId Id="410" Count="13" />
      <LineId Id="440" Count="0" />
      <LineId Id="508" Count="1" />
      <LineId Id="514" Count="0" />
      <LineId Id="441" Count="0" />
      <LineId Id="439" Count="0" />
      <LineId Id="579" Count="4" />
      <LineId Id="548" Count="0" />
      <LineId Id="550" Count="3" />
      <LineId Id="549" Count="0" />
      <LineId Id="490" Count="0" />
      <LineId Id="492" Count="5" />
      <LineId Id="491" Count="0" />
      <LineId Id="424" Count="13" />
      <LineId Id="589" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="275" Count="18" />
      <LineId Id="592" Count="3" />
      <LineId Id="298" Count="5" />
      <LineId Id="596" Count="3" />
      <LineId Id="308" Count="4" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testLengthIsExact">
      <LineId Id="36" Count="4" />
      <LineId Id="320" Count="8" />
      <LineId Id="46" Count="2" />
      <LineId Id="332" Count="0" />
      <LineId Id="331" Count="0" />
      <LineId Id="49" Count="13" />
      <LineId Id="64" Count="5" />
      <LineId Id="71" Count="11" />
      <LineId Id="84" Count="2" />
      <LineId Id="275" Count="3" />
      <LineId Id="91" Count="1" />
      <LineId Id="295" Count="4" />
      <LineId Id="99" Count="4" />
      <LineId Id="105" Count="11" />
      <LineId Id="118" Count="14" />
      <LineId Id="279" Count="3" />
      <LineId Id="137" Count="1" />
      <LineId Id="300" Count="4" />
      <LineId Id="145" Count="4" />
      <LineId Id="151" Count="11" />
      <LineId Id="164" Count="14" />
      <LineId Id="283" Count="3" />
      <LineId Id="183" Count="1" />
      <LineId Id="305" Count="4" />
      <LineId Id="191" Count="4" />
      <LineId Id="197" Count="11" />
      <LineId Id="210" Count="2" />
      <LineId Id="287" Count="3" />
      <LineId Id="217" Count="1" />
      <LineId Id="310" Count="4" />
      <LineId Id="225" Count="4" />
      <LineId Id="231" Count="11" />
      <LineId Id="244" Count="2" />
      <LineId Id="291" Count="3" />
      <LineId Id="251" Count="1" />
      <LineId Id="315" Count="4" />
      <LineId Id="259" Count="4" />
      <LineId Id="265" Count="8" />
      <LineId Id="330" Count="0" />
      <LineId Id="329" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="333" Count="9" />
      <LineId Id="243" Count="0" />
      <LineId Id="343" Count="2" />
      <LineId Id="247" Count="3" />
      <LineId Id="346" Count="1" />
      <LineId Id="253" Count="5" />
      <LineId Id="348" Count="4" />
      <LineId Id="264" Count="0" />
      <LineId Id="353" Count="5" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testLengthIsMax">
      <LineId Id="68" Count="4" />
      <LineId Id="299" Count="8" />
      <LineId Id="78" Count="2" />
      <LineId Id="308" Count="1" />
      <LineId Id="81" Count="212" />
      <LineId Id="310" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="311" Count="38" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testLengthIsMin">
      <LineId Id="35" Count="4" />
      <LineId Id="261" Count="8" />
      <LineId Id="45" Count="2" />
      <LineId Id="272" Count="1" />
      <LineId Id="48" Count="212" />
      <LineId Id="270" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="271" Count="0" />
      <LineId Id="276" Count="35" />
      <LineId Id="274" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testStartsWith">
      <LineId Id="1" Count="1" />
      <LineId Id="59" Count="3" />
      <LineId Id="64" Count="7" />
      <LineId Id="48" Count="0" />
      <LineId Id="4" Count="6" />
      <LineId Id="49" Count="8" />
      <LineId Id="16" Count="13" />
      <LineId Id="58" Count="0" />
      <LineId Id="30" Count="7" />
      <LineId Id="115" Count="0" />
      <LineId Id="72" Count="17" />
      <LineId Id="91" Count="22" />
      <LineId Id="38" Count="0" />
      <LineId Id="114" Count="0" />
      <LineId Id="130" Count="14" />
      <LineId Id="116" Count="13" />
      <LineId Id="145" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testStartsWithIgnoreCase">
      <LineId Id="1" Count="5" />
      <LineId Id="68" Count="3" />
      <LineId Id="73" Count="7" />
      <LineId Id="52" Count="0" />
      <LineId Id="8" Count="6" />
      <LineId Id="58" Count="8" />
      <LineId Id="20" Count="13" />
      <LineId Id="67" Count="0" />
      <LineId Id="34" Count="7" />
      <LineId Id="130" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="81" Count="22" />
      <LineId Id="105" Count="23" />
      <LineId Id="42" Count="0" />
      <LineId Id="142" Count="19" />
      <LineId Id="131" Count="10" />
      <LineId Id="162" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeUtf8StringAssertionTests.testStartsWithTrim">
      <LineId Id="1" Count="3" />
      <LineId Id="126" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="64" Count="3" />
      <LineId Id="69" Count="7" />
      <LineId Id="53" Count="0" />
      <LineId Id="9" Count="6" />
      <LineId Id="54" Count="8" />
      <LineId Id="21" Count="13" />
      <LineId Id="63" Count="0" />
      <LineId Id="35" Count="7" />
      <LineId Id="123" Count="0" />
      <LineId Id="77" Count="14" />
      <LineId Id="124" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="93" Count="4" />
      <LineId Id="99" Count="22" />
      <LineId Id="43" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="141" Count="16" />
      <LineId Id="127" Count="13" />
      <LineId Id="158" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>