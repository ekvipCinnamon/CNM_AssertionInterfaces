<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.12">
  <POU Name="UnicodeAssertions" Id="{6eb90c97-beaa-48d2-a74c-5fce809211d9}" SpecialFunc="None">
    <Declaration><![CDATA[(*

## Short summary
Class provides assert statements
for UTF-8 and UTF-16 strings with an undefined length.

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

{attribute 'reflection'}
FUNCTION_BLOCK INTERNAL UnicodeAssertions EXTENDS AbstractAssertion IMPLEMENTS IUnicodeStringAssertions
VAR
	(* class to handle the utf 8 string assertions *)  
	utf8Assertions	:Utf8StringPointerAssertions();
	(* class to handle the utf 16 string assertions *)  
	utf16Assertions		:Utf16StringPointerAssertions();	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Property Name="className" Id="{4ec3d6b7-8348-4666-a7c4-46a404e354a4}">
      <Declaration><![CDATA[(*

## Short summary
This abstract property returns the class name of the concrete object, 
It's for debugging purpose

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

PROPERTY className :CNM_AbstractObject.ClassName]]></Declaration>
      <Get Name="Get" Id="{39058f21-5dce-40c1-b850-343c6547e7ff}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[className := 'CNM_Assertor.UnicodeAssertions';
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="contains" Id="{0fb8a955-37d5-44a0-8f87-07ee9c5c1e37}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` contains the search string

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD contains
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* string must be found in ``stringToCheck`` *)
	searchString	:ANY_STRING;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* ``TRUE`` means ignore cases; ``FALSE`` means cases must be equal too *)
	ignoreCases		:BOOL := FALSE;
	(*normalize both strings for check*)
	normalizeStrings :BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ((
		stringToCheck.TypeClass <> searchString.TypeClass
	) OR_ELSE (
		stringToCheck.diSize = 0 
	) OR_ELSE ( 
		searchString.diSize = 0 
	)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('contains'));
	RETURN;
END_IF

CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	THIS^.utf8Assertions.contains(
		stringToCheck := stringToCheck.pValue,
		searchString := searchString.pValue,
		ignoreCases := ignoreCases,
		message := message
	);
TYPE_CLASS.TYPE_WSTRING:
	THIS^.utf16Assertions.contains(
		stringToCheck := stringToCheck.pValue,
		searchString := searchString.pValue,
		ignoreCases := ignoreCases,
		message := message,
		normalizeStrings := normalizeStrings
	);
ELSE
	; // do nothing
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="containsNo" Id="{e4ff70aa-64f3-410b-b874-740545914232}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` not contains the search string

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD containsNo
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* string that must not be found in ``stringToCheck`` *)
	searchString	:ANY_STRING;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* ``TRUE`` means ignore cases; ``FALSE`` means cases must be equal too *)
	ignoreCases		:BOOL := FALSE;
	(*normalize both strings for check*)
	normalizeStrings :BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ((
		stringToCheck.TypeClass <> searchString.TypeClass
	) OR_ELSE ( 
		stringToCheck.diSize = 0 
	) OR_ELSE ( 
		searchString.diSize = 0 
	)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('containsNo'));
	RETURN;
END_IF

CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	THIS^.utf8Assertions.containsNo(
		stringToCheck := stringToCheck.pValue,
		searchString := searchString.pValue,
		ignoreCases := ignoreCases,
		message := message
	);
TYPE_CLASS.TYPE_WSTRING:
	THIS^.utf16Assertions.containsNo(
		stringToCheck := stringToCheck.pValue,
		searchString := searchString.pValue,
		ignoreCases := ignoreCases,
		message := message,
		normalizeStrings := normalizeStrings
	);
ELSE
	; // do nothing
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="endsWith" Id="{90fac3ee-ef78-4061-b93e-aa4511f586cd}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` ends with ``end``

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

**Attention:** 
	end of the string is **ALWAYS** the right side of the string 
	even for writings which written from right to left like Hebrew or Arabic

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD endsWith
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* expected end of ``stringToCheck`` *)
	end				:ANY_STRING;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* ``TRUE`` means ignore cases; ``FALSE`` means cases must be equal too *)
	ignoreCases		:BOOL := FALSE;
	(* ``TRUE`` means truncation of spaces on the right side of ``stringToCheck``*)
	trim			:BOOL := FALSE;
	(*normalize both strings for check*)
	normalizeStrings :BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ((
		stringToCheck.TypeClass <> end.TypeClass
	) OR_ELSE (
		 stringToCheck.diSize = 0
	) OR_ELSE (
		 end.diSize = 0
	)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('endsWith'));
	RETURN;
END_IF

CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	THIS^.utf8Assertions.endsWith(
		stringToCheck := stringToCheck.pValue,
		end := end.pValue,
		ignoreCases := ignoreCases,
		trim := trim,
		message := message,
		normalizeStrings := normalizeStrings
	);
TYPE_CLASS.TYPE_WSTRING:
	THIS^.utf16Assertions.endsWith(
		stringToCheck := stringToCheck.pValue,
		end := end.pValue,
		ignoreCases := ignoreCases,
		trim := trim,
		message := message,
		normalizeStrings := normalizeStrings
	);
ELSE
	; // do nothing
END_CASE 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isEmpty" Id="{1ffa318f-febc-413c-b8ea-43cd30164c29}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` is empty

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD isEmpty
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR CONSTANT
	(* strings are null terminated *)
	END_OF_UTF8_STRING	:BYTE := 16#00;
	(* strings are null terminated *)
	END_OF_UTF16_STRING	:WORD := 16#0000;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	IF (stringToCheck.pValue^ <> END_OF_UTF8_STRING) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('isEmpty'));
	END_IF
TYPE_CLASS.TYPE_WSTRING:
	IF (stringToCheck.pValue^ <> END_OF_UTF16_STRING) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('isEmpty'));
	END_IF
ELSE
	; // do nothing
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isEqualTo" Id="{86303471-64b7-429a-9d3c-6632910f7fc6}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` is equal to ``expected``

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD isEqualTo
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* ``stringToCheck`` must be equal to expected *)
	expected		:ANY_STRING;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* ``TRUE`` means ignore cases; ``FALSE`` means cases must be equal too *)
	ignoreCases		:BOOL := FALSE;
	(*normalize both strings for check*)
	normalizeStrings :BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ((
		stringToCheck.TypeClass <> expected.TypeClass
	) OR_ELSE ( 
		stringToCheck.diSize = 0
	) OR_ELSE ( 
		expected.diSize = 0 
	)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('isEqualTo'));
	RETURN;
END_IF

CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	THIS^.utf8Assertions.isEqualTo(
		stringToCheck := stringToCheck.pValue,
		expected := expected.pValue,
		ignoreCases := ignoreCases,
		message := message
	);
TYPE_CLASS.TYPE_WSTRING:
	THIS^.utf16Assertions.isEqualTo(
		stringToCheck := stringToCheck.pValue,
		expected := expected.pValue,
		ignoreCases := ignoreCases,
		message := message,
		normalizeStrings := normalizeStrings
	);	
ELSE
	; // do nothing
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="isNotEmpty" Id="{0ce2136c-c795-45e3-87c9-6824f0b8fe14}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` is not empty

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD isNotEmpty
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR CONSTANT
	(* strings are null terminated *)
	END_OF_UTF8_STRING	:BYTE := 16#00;
	(* strings are null terminated *)
	END_OF_UTF16_STRING	:WORD := 16#0000;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	IF (stringToCheck.pValue^ = END_OF_UTF8_STRING) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('isNotEmpty'));
	END_IF
TYPE_CLASS.TYPE_WSTRING:
	IF (stringToCheck.pValue^ = END_OF_UTF16_STRING) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('isNotEmpty'));
	END_IF
ELSE
	; // do nothing
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isNotEqualTo" Id="{28f0dcb9-56e8-4624-a242-502d5b4e1d5a}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` is not equal to ``unexpected``

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD isNotEqualTo
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* ``stringToCheck`` must be not equal to expected *)
	unexpected		:ANY_STRING;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* ``TRUE`` means ignore cases; ``FALSE`` means cases must be equal too *)
	ignoreCases		:BOOL := FALSE;
	(*normalize both strings for check*)
	normalizeStrings :BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ((
		stringToCheck.TypeClass <> unexpected.TypeClass
	) OR_ELSE ( 
		stringToCheck.diSize = 0 
	) OR_ELSE ( 
		unexpected.diSize = 0 
	)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('isNotEqualTo'));
	RETURN;
END_IF

CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	THIS^.utf8Assertions.isNotEqualTo(
		stringToCheck := stringToCheck.pValue,
		unexpected := unexpected.pValue,
		ignoreCases := ignoreCases,
		message := message
	);
TYPE_CLASS.TYPE_WSTRING:
	THIS^.utf16Assertions.isNotEqualTo(
		stringToCheck := stringToCheck.pValue,
		unexpected := unexpected.pValue,
		ignoreCases := ignoreCases,
		message := message,
		normalizeStrings := normalizeStrings
	);	
ELSE
	; // do nothing
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="lengthIsBetween" Id="{9c820b83-87dc-4349-bc7f-d4a4dbcc2566}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` is length
is between ``minLength`` and ``maxLength``

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD lengthIsBetween
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* lower limit of the string length *)
	minLength		:UDINT;
	(* upper limit of the string length *)
	maxLength		:UDINT;
	(* string length units of measurement *)
	stringLengthUnit	:UnicodeStringLengthUnit;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	THIS^.utf8Assertions.lengthIsBetween(
		stringToCheck	:= stringToCheck.pValue,
		minLength		:= minLength,
		maxLength		:= maxLength,
		stringLengthUnit := stringLengthUnit,
		message			:= message		
	);
TYPE_CLASS.TYPE_WSTRING:
	THIS^.utf16Assertions.lengthIsBetween(
		stringToCheck	:= stringToCheck.pValue,
		minLength		:= minLength,
		maxLength		:= maxLength,
		stringLengthUnit := stringLengthUnit,
		message			:= message
	);
ELSE
	; // do nothing
END_CASE 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="lengthIsExact" Id="{cb47af8f-b329-4543-9187-daf362a7be79}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` is length
is equal to ``expectedLength``

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD lengthIsExact
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* expected length of ``stringToCheck`` *)
	expectedLength	:UDINT;
	(* string length units of measurement *)
	stringLengthUnit	:UnicodeStringLengthUnit;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	THIS^.utf8Assertions.lengthIsExact(
		stringToCheck	:= stringToCheck.pValue,
		expectedLength	:= expectedLength,
		stringLengthUnit := stringLengthUnit,
		message			:= message
	);
TYPE_CLASS.TYPE_WSTRING:
	THIS^.utf16Assertions.lengthIsExact(
		stringToCheck	:= stringToCheck.pValue,
		expectedLength	:= expectedLength,
		stringLengthUnit := stringLengthUnit,
		message			:= message
	);
ELSE
	; // do nothing
END_CASE 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="lengthIsMax" Id="{f39159bf-e9b2-4fb8-9aed-db3dffac9216}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` is length
is equal or less than to ``maxLength``

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer   

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD lengthIsMax
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* upper limit of the length of ``stringToCheck`` *)
	maxLength		:UDINT;
	(* string length units of measurement *)
	stringLengthUnit	:UnicodeStringLengthUnit;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	THIS^.utf8Assertions.lengthIsMax(
		stringToCheck	:= stringToCheck.pValue,
		maxLength		:= maxLength,
		stringLengthUnit := stringLengthUnit,
		message			:= message
	);
TYPE_CLASS.TYPE_WSTRING:
	THIS^.utf16Assertions.lengthIsMax(
		stringToCheck	:= stringToCheck.pValue,
		maxLength		:= maxLength,
		stringLengthUnit := stringLengthUnit,
		message			:= message
	);
ELSE
	; // do nothing
END_CASE 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="lengthIsMin" Id="{127554fc-0080-4c99-9128-b661d9fec7bf}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` is length
is equal or grater than to ``minLength``

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD lengthIsMin
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* lower limit of the length of ``stringToCheck`` *)
	minLength		:UDINT;
	(* string length units of measurement *)
	stringLengthUnit	:UnicodeStringLengthUnit;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	THIS^.utf8Assertions.lengthIsMin(
		stringToCheck	:= stringToCheck.pValue,
		minLength		:= minLength,
		stringLengthUnit := stringLengthUnit,
		message			:= message
	);
TYPE_CLASS.TYPE_WSTRING:
	THIS^.utf16Assertions.lengthIsMin(
		stringToCheck	:= stringToCheck.pValue,
		minLength		:= minLength,
		stringLengthUnit := stringLengthUnit,
		message			:= message
	);
ELSE
	; // do nothing
END_CASE 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="setCallBack" Id="{5ed55fc0-2e30-4ee2-a537-9fd1dad1def5}">
      <Declaration><![CDATA[(*

## Short summary
This methods is the setter for the callback class if an assertion was false

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD setCallBack
VAR_INPUT
	(* the class that must be informed if an assertion is false *)
	callBack	:IAssertCallBack;  
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.setCallBack(callBack);
THIS^.utf8Assertions.setCallBack(callBack);
THIS^.utf16Assertions.setCallBack(callBack);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="startsWith" Id="{f495fe04-150f-4fe7-88aa-bec028123c1f}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` starts with ``start``

**Attention:** 
	All strings are handled as null terminated byte/word streams.
	For UTF-8 is end of the string 16#00
	For UTF-16 is end of the string 16#00_00

**Attention:** 
	The interface `IUnicodeAssertions` uses ``ANY_STRING``, 
	for this it's not possible to use literals/constants,
	because for ``ANY`` types generates the compiler ``__SYSTEM.AnyType``
	and ``__SYSTEM.AnyType`` contains a pointer  

**Attention:** 
	start of the string is **ALWAYS** the left side of the string 
	even for writings which written from right to left like Hebrew or Arabic

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD startsWith
VAR_INPUT
	(* current string to check *)
	stringToCheck	:ANY_STRING;
	(* expected start of ``stringToCheck`` *)
	start			:ANY_STRING;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* ``TRUE`` means ignore cases; ``FALSE`` means cases must be equal too *)
	ignoreCases		:BOOL := FALSE;
	(* ``TRUE`` means truncation of spaces on the left side of ``stringToCheck``*)
	trim			:BOOL := FALSE;
	(*normalize both strings for check*)
	normalizeStrings :BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ((
		stringToCheck.TypeClass <> start.TypeClass
	) OR_ELSE (
		stringToCheck.diSize = 0 
	) OR_ELSE ( 
		start.diSize = 0 
	)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('startsWith'));
	RETURN;
END_IF

CASE stringToCheck.TypeClass OF
TYPE_CLASS.TYPE_STRING:
	THIS^.utf8Assertions.startsWith(
		stringToCheck := stringToCheck.pValue,
		start := start.pValue,
		ignoreCases := ignoreCases,
		trim := trim,
		message := message,
		normalizeStrings := normalizeStrings
	);
TYPE_CLASS.TYPE_WSTRING:
	THIS^.utf16Assertions.startsWith(
		stringToCheck := stringToCheck.pValue,
		start := start.pValue,
		ignoreCases := ignoreCases,
		trim := trim,
		message := message,
		normalizeStrings := normalizeStrings
	);
ELSE
	; // do nothing
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="UnicodeAssertions">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.className.Get">
      <LineId Id="1" Count="1" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.contains">
      <LineId Id="1" Count="0" />
      <LineId Id="47" Count="6" />
      <LineId Id="2" Count="2" />
      <LineId Id="41" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="30" Count="4" />
      <LineId Id="28" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="35" Count="5" />
      <LineId Id="29" Count="0" />
      <LineId Id="45" Count="1" />
      <LineId Id="26" Count="0" />
      <LineId Id="21" Count="1" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.containsNo">
      <LineId Id="23" Count="0" />
      <LineId Id="49" Count="5" />
      <LineId Id="26" Count="2" />
      <LineId Id="4" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="36" Count="4" />
      <LineId Id="34" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="41" Count="5" />
      <LineId Id="35" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="21" Count="1" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.endsWith">
      <LineId Id="26" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="56" Count="3" />
      <LineId Id="29" Count="2" />
      <LineId Id="4" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="37" Count="6" />
      <LineId Id="36" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="46" Count="6" />
      <LineId Id="45" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="25" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.isEmpty">
      <LineId Id="1" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="2" Count="6" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="9" Count="1" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.isEqualTo">
      <LineId Id="23" Count="0" />
      <LineId Id="51" Count="5" />
      <LineId Id="26" Count="2" />
      <LineId Id="5" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="37" Count="4" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="42" Count="5" />
      <LineId Id="36" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="21" Count="1" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.isNotEmpty">
      <LineId Id="1" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="2" Count="6" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="9" Count="1" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.isNotEqualTo">
      <LineId Id="24" Count="0" />
      <LineId Id="51" Count="5" />
      <LineId Id="27" Count="20" />
      <LineId Id="50" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="21" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.lengthIsBetween">
      <LineId Id="18" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="24" Count="5" />
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="30" Count="5" />
      <LineId Id="23" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.lengthIsExact">
      <LineId Id="17" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="24" Count="4" />
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="29" Count="4" />
      <LineId Id="23" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.lengthIsMax">
      <LineId Id="17" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="24" Count="4" />
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="32" Count="4" />
      <LineId Id="30" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.lengthIsMin">
      <LineId Id="17" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="24" Count="4" />
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="29" Count="4" />
      <LineId Id="23" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.setCallBack">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="UnicodeAssertions.startsWith">
      <LineId Id="26" Count="0" />
      <LineId Id="56" Count="5" />
      <LineId Id="29" Count="2" />
      <LineId Id="4" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="37" Count="6" />
      <LineId Id="36" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="46" Count="6" />
      <LineId Id="45" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="25" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>