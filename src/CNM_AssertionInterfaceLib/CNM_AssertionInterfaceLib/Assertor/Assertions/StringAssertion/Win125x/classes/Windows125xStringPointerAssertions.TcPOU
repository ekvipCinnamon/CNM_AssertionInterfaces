<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.12">
  <POU Name="Windows125xStringPointerAssertions" Id="{c80c2bee-232c-48bb-89ab-8c679cbda050}" SpecialFunc="None">
    <Declaration><![CDATA[(*

## Short summary
This class provides assert statements for Windows-1252 and Windows-1251 strings.
Used encoding is specified in ``Tc2_Utilities.GLOBAL_SBCS_TABLE`` global variable

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

{attribute 'reflection'}
FUNCTION_BLOCK INTERNAL Windows125xStringPointerAssertions EXTENDS AbstractStringPointerAssertions IMPLEMENTS IWindows125xStringPointerAssertions]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="protected" Id="{ee6fcd7b-3ff7-4220-83b6-dbf965193e3d}" />
    <Property Name="className" Id="{23df8257-1c46-4060-8c10-6fc7b5032616}">
      <Declaration><![CDATA[(*

## Short summary
This abstract property returns the class name of the concrete object, 
It's for debugging purpose

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

PROPERTY className :CNM_AbstractObject.ClassName]]></Declaration>
      <Get Name="Get" Id="{318472ee-a9f4-42c2-bd01-82d377216e9e}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[className := 'CNM_Assertor.Windows125xStringPointerAssertions';]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="contains" Id="{38774a57-29b0-489a-b427-a422b528aec7}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` contains the search string ``searchString``.
Processed strings must be in Windows-1252 or Windows-1251 encoding

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD contains
VAR_INPUT
	(* current string to check *)
	stringToCheck	:POINTER TO BYTE;
	(* string must be found in ``stringToCheck`` *)
	searchString	:POINTER TO BYTE;
	(* ``TRUE`` means ignore cases; ``FALSE`` means that cases must be equal too *)
	ignoreCases		:BOOL;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* used Single Byte Character Set (SBCS), is set in Tc2_Utilities.GLOBAL_SBCS_TABLE *)
	sbcsType 		:Tc2_Utilities.E_SBCSType := Tc2_Utilities.E_SBCSType.eSBCS_WesternEuropean;
END_VAR
VAR
	(* length of current string to check *)
	lengthStringToCheck	:UDINT;
	(* length of ``searchString`` *)
	lengthSearchString	:UDINT;
	(* difference between string length and search string length *)
	maxSearchIndex :UDINT;
	(* string address we use to compare, if it's case sensitive it's equal to ``stringToCheck`` *)
	usedStringToCheck	:POINTER TO BYTE;
	(* seacrch string address we use to compare, if it's case sensitive it's equal to ``searchString`` *)
	usedSearchString	:POINTER TO BYTE;
	(* character index for the comperation *)
	character			:UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[lengthStringToCheck := THIS^.getStringLength(stringToCheck);
lengthSearchString := THIS^.getStringLength(searchString);

IF (
	NOT THIS^.isContainsCheckNecessary(
		stringToCheck		:= stringToCheck,
		searchString		:= searchString,
		lengthStringToCheck	:= lengthStringToCheck,
		lengthSearchString	:= lengthSearchString,
		additionalText		:= THIS^.getDebugInfo('contains'),
		message				:= message
	)
) THEN
	RETURN;
END_IF

usedStringToCheck := THIS^.getNewUpperCaseString(stringToCheck, lengthStringToCheck, ignoreCases, sbcsType := sbcsType);
usedSearchString := THIS^.getNewUpperCaseString(searchString, lengthSearchString, ignoreCases, sbcsType := sbcsType);
IF ignoreCases AND_THEN ((usedStringToCheck = 0) OR_ELSE (usedSearchString = 0)) THEN
	THIS^.assertionWasWrong(message := message, additionalText := THIS^.getDebugInfo('contains, malloc failed'));
	RETURN;
END_IF

maxSearchIndex := lengthStringToCheck - lengthSearchString;
FOR (character := 0) TO (maxSearchIndex) DO
	IF (Tc2_System.MEMCMP(
			ADR(usedStringToCheck[character]),
			usedSearchString, 
			lengthSearchString
		) = CNM_ReturnTypes.ComparationResult.EQUAL
	) THEN
		THIS^.freeMemory(usedStringToCheck, ignoreCases);
		THIS^.freeMemory(usedSearchString, ignoreCases);		
		RETURN; //assert is true
	END_IF; 
END_FOR

THIS^.assertionWasWrong(message, THIS^.getDebugInfo('contains'));
THIS^.freeMemory(usedStringToCheck, ignoreCases);
THIS^.freeMemory(usedSearchString, ignoreCases);		]]></ST>
      </Implementation>
    </Method>
    <Method Name="containsNo" Id="{75135cdc-b182-40c4-941d-c7bf1f07d3b2}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` doesn't contain the search string ``searchString``.
Processed strings must be in Windows-1252 or Windows-1251 encoding

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD containsNo
VAR_INPUT
	(* current string to check *)
	stringToCheck	:POINTER TO BYTE;
	(* string must be found in ``stringToCheck`` *)
	searchString	:POINTER TO BYTE;
	(* ``TRUE`` means ignore cases; ``FALSE`` means that cases must be equal too *)
	ignoreCases		:BOOL;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* used Single Byte Character Set (SBCS), is set in Tc2_Utilities.GLOBAL_SBCS_TABLE *)
	sbcsType 		:Tc2_Utilities.E_SBCSType := Tc2_Utilities.E_SBCSType.eSBCS_WesternEuropean;
END_VAR
VAR
	(* length of current string to check *)
	lengthStringToCheck	:UDINT;
	(* length of ``searchString`` *)
	lengthSearchString	:UDINT;
	(* difference between string length and search string length *)
	maxSearchIndex :UDINT;
	(* string address we use to compare, if it's case sensitive it's equal to ``stringToCheck`` *)
	usedStringToCheck	:POINTER TO BYTE;
	(* seacrch string address we use to compare, if it's case sensitive it's equal to ``searchString`` *)
	usedSearchString	:POINTER TO BYTE;
	(* character index for the comperation *)
	character			:UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[lengthStringToCheck := THIS^.getStringLength(stringToCheck);
lengthSearchString := THIS^.getStringLength(searchString);

IF (
	NOT THIS^.isContainsNoCheckNecessary(
		stringToCheck		:= stringToCheck,
		searchString		:= searchString,
		lengthStringToCheck	:= lengthStringToCheck,
		lengthSearchString	:= lengthSearchString,
		additionalText		:= THIS^.getDebugInfo('containsNo'),
		message				:= message
	)
) THEN
	RETURN;
END_IF

usedStringToCheck := THIS^.getNewUpperCaseString(stringToCheck, lengthStringToCheck, ignoreCases, sbcsType := sbcsType);
usedSearchString := THIS^.getNewUpperCaseString(searchString, lengthSearchString, ignoreCases, sbcsType := sbcsType);
maxSearchIndex := lengthStringToCheck - lengthSearchString;
FOR (character := 0) TO maxSearchIndex DO
	IF (Tc2_System.MEMCMP(
			ADR(usedStringToCheck[character]),
			usedSearchString, 
			lengthSearchString
		) = CNM_ReturnTypes.ComparationResult.EQUAL
	) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('containsNo'));
		THIS^.freeMemory(usedStringToCheck, ignoreCases);
		THIS^.freeMemory(usedSearchString, ignoreCases);		
		RETURN;
	END_IF; 
END_FOR

THIS^.freeMemory(usedStringToCheck, ignoreCases);
THIS^.freeMemory(usedSearchString, ignoreCases);		]]></ST>
      </Implementation>
    </Method>
    <Method Name="endsWith" Id="{d7488fd9-8d7f-4140-999a-c27d4cfbd9f3}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` ends with the string ``end``.
Processed strings must be in Windows-1252 or Windows-1251 encoding

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD endsWith
VAR_INPUT
	(* current string to check *)
	stringToCheck	:POINTER TO BYTE;
	(* string must be the end of ``stringToCheck`` *)
	end				:POINTER TO BYTE;
	(* ``TRUE`` means ignore cases; ``FALSE`` means that cases must be equal too *)
	ignoreCases		:BOOL;
	(* ``TRUE`` means truncation of spaces on the right side of ``stringToCheck``*)
	trim		:BOOL;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* used Single Byte Character Set (SBCS), is set in Tc2_Utilities.GLOBAL_SBCS_TABLE *)
	sbcsType 		:Tc2_Utilities.E_SBCSType := Tc2_Utilities.E_SBCSType.eSBCS_WesternEuropean;
END_VAR
VAR
	(* length of current string to check *)
	lengthStringToCheck	:UDINT;
	(* length of ``end`` *)
	lengthOfEnd			:UDINT;
	(* string address we use to compare, if it's case sensitive it's equal to ``stringToCheck`` *)
	usedStringToCheck	:POINTER TO BYTE;
	(* seacrch string address we use to compare, if it's case sensitive it's equal to ``end`` *)
	usedEndString		:POINTER TO BYTE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[lengthStringToCheck := THIS^.getStringLength(stringToCheck);
lengthOfEnd := THIS^.getStringLength(end);

THIS^.trimRight(stringToCheck, lengthStringToCheck, trim);
THIS^.trimRight(end, lengthOfEnd, trim);

IF (
	NOT THIS^.isContainsCheckNecessary(
		stringToCheck		:= stringToCheck,
		searchString		:= end,
		lengthStringToCheck	:= lengthStringToCheck,
		lengthSearchString	:= lengthOfEnd,
		additionalText		:= THIS^.getDebugInfo('endsWith'),
		message				:= message
	)
) THEN
	RETURN;
END_IF

usedStringToCheck := THIS^.getNewUpperCaseString(stringToCheck, lengthStringToCheck, ignoreCases, sbcsType := sbcsType);
usedEndString := THIS^.getNewUpperCaseString(end, lengthOfEnd, ignoreCases, sbcsType := sbcsType);

IF (Tc2_System.MEMCMP(
		ADR(usedStringToCheck[lengthStringToCheck - lengthOfEnd]),
		usedEndString, 
		lengthOfEnd
	) <> CNM_ReturnTypes.ComparationResult.EQUAL
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('endsWith'));
END_IF;

THIS^.freeMemory(usedStringToCheck, ignoreCases);
THIS^.freeMemory(usedEndString, ignoreCases);		]]></ST>
      </Implementation>
    </Method>
    <Method Name="freeMemory" Id="{322ed449-78de-4a3f-a362-c393a8146522}" FolderPath="protected\">
      <Declaration><![CDATA[(*

## Short summary
This method is used to free allocated memory if needed

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD PROTECTED freeMemory
VAR_INPUT
	(* start address of the memory to free *)
	stringAddress	:POINTER TO BYTE;
	(* ``TRUE`` means free the memory, ``FALSE`` means do not free the memory *)
	freeAllocatedMemory		:BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (freeAllocatedMemory) THEN
	__DELETE(stringAddress);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="getNewUpperCaseString" Id="{8d7ed912-cc0c-48a5-90db-081b765b4ade}" FolderPath="protected\">
      <Declaration><![CDATA[(*

## Short summary
this methods copy a string and returns the start address of new string,
all small letters are capitalized in the new string.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>


:return: start address of a string. 
If ``createNewUpperCaseString`` is ``TRUE`` then it's a new string

*)

METHOD PROTECTED getNewUpperCaseString :POINTER TO BYTE; 
VAR_INPUT
	(* start address of the string to copy and capitalize *)
	stringAddress				:POINTER TO BYTE;
	(* length of the string ``stringAddress`` *)
	stringLength				:UDINT;
	(* 
	``TRUE means meake a copy and capitalize it, 
	``FALSE`` means return just ``stringAddress``
	and do nothing else
	*)
	createNewUpperCaseString	:BOOL;
	(* used Single Byte Character Set (SBCS), is set in Tc2_Utilities.GLOBAL_SBCS_TABLE *)
	sbcsType 		:Tc2_Utilities.E_SBCSType := Tc2_Utilities.E_SBCSType.eSBCS_WesternEuropean;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (createNewUpperCaseString) THEN
	getNewUpperCaseString := THIS^.getStringCopy(stringAddress, stringLength);
	THIS^.upperCase(getNewUpperCaseString, stringLength, sbcsType := sbcsType);
ELSE
	getNewUpperCaseString := stringAddress;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getStringCopy" Id="{5a15cda7-f8cf-4340-a12c-aa9843851922}" FolderPath="protected\">
      <Declaration><![CDATA[(*

## Short summary
this methods copy a string and returns the start address of new string

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>


:return: start address of the string copy

*)

METHOD PROTECTED getStringCopy :POINTER TO BYTE
VAR_INPUT
	(* string to copy *)
	stringAddress		:POINTER TO BYTE;
	(* length of the string *)
	stringLength		:UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getStringCopy := __NEW(BYTE, stringLength);
IF (getStringCopy <> 0) THEN
	Tc2_System.MEMCPY(
		destAddr := getStringCopy,
		srcAddr := stringAddress,
		n := stringLength
	);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="getStringLength" Id="{8fe8c0d0-11b7-4fc7-834f-4ea0333442b7}" FolderPath="protected\">
      <Declaration><![CDATA[(*

## Short summary
this methods returns the length of a null-terminated string in bytes

**Attention:** 
	All strings are handled as null-terminated byte streams.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>


:return: length of the string

*)

METHOD PROTECTED getStringLength :UDINT
VAR_INPUT
	(* Start address of the string for which the length is to be determined *)
	stringAddress	:POINTER TO BYTE;
END_VAR
VAR CONSTANT
	(* the end of string marker *)
	END_OF_STRING	:BYTE := 16#00;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[getStringLength := 0;
RETURN(stringAddress = 0);

WHILE (stringAddress[getStringLength] <> END_OF_STRING) DO
	getStringLength := getStringLength + 1;
END_WHILE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isCharWhiteSpace" Id="{1ac08874-1079-4b60-b29a-3e1ecfac6d41}" FolderPath="protected\">
      <Declaration><![CDATA[(*

## Short summary
this methods checks if a windows-1252 or a windows-1251 character is a whitespace character

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>


:return: ``TRUE`` means ``character`` is whitespace,
``FALSE`` means ``character`` is no whitespace 

*)

METHOD PROTECTED isCharWhiteSpace :BOOL
VAR_INPUT
	(* character to check if it's whitespace *)
	character	:BYTE;
END_VAR
VAR CONSTANT
	SPACE			:BYTE := 16#20;
	HORIZONTAL_TAB	:BYTE := 16#09;
	LINE_FEED		:BYTE := 16#0A;
	VERTICAL_TAB	:BYTE := 16#0B;
	FROM_FEED		:BYTE := 16#0C;
	CARRIAGE_RETURN	:BYTE := 16#0D;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE character OF
HORIZONTAL_TAB .. CARRIAGE_RETURN,
SPACE:
	isCharWhiteSpace := TRUE;
ELSE
	isCharWhiteSpace := FALSE;	
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isEqualTo" Id="{6b0e075d-21c5-4154-9b89-67d1c0f5ca41}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` is equal to ``expected``.
Processed strings must be in Windows-1252 or Windows-1251 encoding

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD isEqualTo
VAR_INPUT
	(* current string to check *)
	stringToCheck	:POINTER TO BYTE;
	(* ``stringToCheck`` must be equal to expected *)
	expected		:POINTER TO BYTE;
	(* ``TRUE`` means ignore cases; ``FALSE`` means that cases must be equal too *)
	ignoreCases		:BOOL;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* used Single Byte Character Set (SBCS), is set in Tc2_Utilities.GLOBAL_SBCS_TABLE *)
	sbcsType 		:Tc2_Utilities.E_SBCSType := Tc2_Utilities.E_SBCSType.eSBCS_WesternEuropean;
END_VAR
VAR
	(* length of current string to check *)
	lengthStringToCheck		:UDINT;
	(* length of ``expected`` *)
	lengthExpectedString	:UDINT;
	(* string address we use to compare, if it's case sensitive it's equal to ``stringToCheck`` *)
	usedStringToCheck		:POINTER TO BYTE;
	(* seacrch string address we use to compare, if it's case sensitive it's equal to ``expected`` *)
	usedExpectedString		:POINTER TO BYTE;
END_VAR
VAR CONSTANT
	(* length of an empty string to avoid Tc2_System.MEMCMP with length 0 *)
	EMPTY_STRING_LENGTH		:UDINT := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[lengthStringToCheck := THIS^.getStringLength(stringToCheck);
lengthExpectedString := THIS^.getStringLength(expected);

IF lengthStringToCheck <> lengthExpectedString THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('isEqualTo'));
	RETURN;
ELSIF (lengthExpectedString = EMPTY_STRING_LENGTH) THEN
	RETURN;
END_IF

usedStringToCheck := THIS^.getNewUpperCaseString(stringToCheck, lengthStringToCheck, ignoreCases, sbcsType := sbcsType);
usedExpectedString := THIS^.getNewUpperCaseString(expected, lengthExpectedString, ignoreCases, sbcsType := sbcsType);

IF (Tc2_System.MEMCMP(
		usedStringToCheck,
		usedExpectedString, 
		lengthExpectedString
	) <> CNM_ReturnTypes.ComparationResult.EQUAL
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('isEqualTo'));
END_IF;

THIS^.freeMemory(usedStringToCheck, ignoreCases);
THIS^.freeMemory(usedExpectedString, ignoreCases);		]]></ST>
      </Implementation>
    </Method>
    <Method Name="isNotEqualTo" Id="{c4ab66db-1664-416a-87da-439f73d68193}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` is not equal to ``unexpected``.
Processed strings must be in Windows-1252 or Windows-1251 encoding

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD isNotEqualTo
VAR_INPUT
	(* current string to check *)
	stringToCheck	:POINTER TO BYTE;
	(* ``stringToCheck`` must be not equal to expected *)
	unexpected		:POINTER TO BYTE;
	(* ``TRUE`` means ignore cases; ``FALSE`` means that cases must be equal too *)
	ignoreCases		:BOOL;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* used Single Byte Character Set (SBCS), is set in Tc2_Utilities.GLOBAL_SBCS_TABLE *)
	sbcsType 		:Tc2_Utilities.E_SBCSType := Tc2_Utilities.E_SBCSType.eSBCS_WesternEuropean;
END_VAR
VAR
	(* length of current string to check *)
	lengthStringToCheck		:UDINT;
	(* length of ``unexpected`` *)
	lengthUnexpectedString	:UDINT;
	(* string address we use to compare, if it's case sensitive it's equal to ``stringToCheck`` *)
	usedStringToCheck		:POINTER TO BYTE;
	(* seacrch string address we use to compare, if it's case sensitive it's equal to ``expected`` *)
	usedUnexpectedString	:POINTER TO BYTE;
END_VAR
VAR CONSTANT
	(* length of an empty string to avoid Tc2_System.MEMCMP with length 0 *)
	EMPTY_STRING_LENGTH		:UDINT := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[lengthStringToCheck := THIS^.getStringLength(stringToCheck);
lengthUnexpectedString := THIS^.getStringLength(unexpected);

IF lengthStringToCheck = EMPTY_STRING_LENGTH AND_THEN lengthUnexpectedString = EMPTY_STRING_LENGTH THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('isNotEqualTo'));
	RETURN;
END_IF

usedStringToCheck := THIS^.getNewUpperCaseString(stringToCheck, lengthStringToCheck, ignoreCases, sbcsType := sbcsType);
usedUnexpectedString := THIS^.getNewUpperCaseString(unexpected, lengthUnexpectedString, ignoreCases, sbcsType := sbcsType);

IF ( 
	(lengthStringToCheck = lengthUnexpectedString)
	AND_THEN
	Tc2_System.MEMCMP(
		usedStringToCheck,
		usedUnexpectedString, 
		lengthUnexpectedString
	) = CNM_ReturnTypes.ComparationResult.EQUAL
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('isNotEqualTo'));
END_IF;

THIS^.freeMemory(usedStringToCheck, ignoreCases);
THIS^.freeMemory(usedUnexpectedString, ignoreCases);		]]></ST>
      </Implementation>
    </Method>
    <Method Name="lengthIsBetween" Id="{266f4184-c57d-4876-93d5-8d85245f9490}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` length is between ``minLength`` and ``maxLength``.
Processed strings must be in Windows-1252 or Windows-1251 encoding

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD lengthIsBetween
VAR_INPUT
	(* current string to check *)
	stringToCheck	:POINTER TO BYTE;
	(* lower limit of the string length *)
	minLength		:UDINT;
	(* upper limit of the string length *)
	maxLength		:UDINT;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* length of ``stringToCheck`` *)
	lengthStringToCheck	:UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF minLength > maxLength THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('lengthIsBetween'));
	RETURN;
END_IF

lengthStringToCheck := THIS^.getStringLength(stringToCheck);

IF lengthStringToCheck < minLength OR_ELSE lengthStringToCheck > maxLength THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('lengthIsBetween'));
END_IF;]]></ST>
      </Implementation>
    </Method>
    <Method Name="lengthIsExact" Id="{a96ee607-d87a-4217-827b-ab83196f5150}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` length is equal to ``expectedLength``.
Processed strings must be in Windows-1252 or Windows-1251 encoding

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD lengthIsExact
VAR_INPUT
	(* current string to check *)
	stringToCheck	:POINTER TO BYTE;
	(* expected length of ``stringToCheck`` *)
	expectedLength	:UDINT;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.getStringLength(stringToCheck) <> expectedLength) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('LengthIsExact'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="lengthIsMax" Id="{79d05ad0-86c7-495e-8a31-f6f9897d0f5b}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` length is equal or less than to ``maxLength``.
Processed strings must be in Windows-1252 or Windows-1251 encoding

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD lengthIsMax
VAR_INPUT
	(* current string to check *)
	stringToCheck	:POINTER TO BYTE;
	(* upper limit of the length of ``stringToCheck`` *)
	maxLength		:UDINT;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.getStringLength(stringToCheck) > maxLength) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('LengthIsMax'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="lengthIsMin" Id="{8875af09-17da-4e02-b117-e13b70af8820}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` length is equal or greater than to ``minLength``.
Processed strings must be in Windows-1252 or Windows-1251 encoding

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD lengthIsMin
VAR_INPUT
	(* current string to check *)
	stringToCheck	:POINTER TO BYTE;
	(* lower limit of the length of ``stringToCheck`` *)
	minLength		:UDINT;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.getStringLength(stringToCheck) < minLength) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('LengthIsMin'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="startsWith" Id="{eafb90c4-dea4-42db-acaa-06c3e5b4db41}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current string ``stringToCheck`` starts with string ``start``.
Processed strings must be in Windows-1252 or Windows-1251 encoding

**Attention:** 
	All strings are handled as null-terminated byte streams

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD startsWith
VAR_INPUT
	(* current string to check *)
	stringToCheck	:POINTER TO BYTE;
	(* expected start of ``stringToCheck`` *)
	start			:POINTER TO BYTE;
	(* ``TRUE`` means ignore cases; ``FALSE`` means that cases must be equal too *)
	ignoreCases		:BOOL;
	(* ``TRUE`` means truncation of spaces on the left side of ``stringToCheck``*)
	trim		:BOOL;
	(* message if the assertion is false *)
	message			:AssertMessage;
	(* used Single Byte Character Set (SBCS), is set in Tc2_Utilities.GLOBAL_SBCS_TABLE *)
	sbcsType 		:Tc2_Utilities.E_SBCSType := Tc2_Utilities.E_SBCSType.eSBCS_WesternEuropean;
END_VAR
VAR
	(* length of current string to check *)
	lengthStringToCheck	:UDINT;
	(* length of ``start`` *)
	lengthOfStart		:UDINT;
	(* string address we use to compare, if it's case sensitive it's equal to ``stringToCheck`` *)
	usedStringToCheck	:POINTER TO BYTE;
	(* seacrch string address we use to compare, if it's case sensitive it's equal to ``start`` *)
	usedStartString		:POINTER TO BYTE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[lengthStringToCheck := THIS^.getStringLength(stringToCheck);
lengthOfStart := THIS^.getStringLength(start);

THIS^.trimLeft(stringToCheck, lengthStringToCheck, trim);
THIS^.trimLeft(start, lengthOfStart, trim);

IF (
	NOT THIS^.isContainsCheckNecessary(
		stringToCheck		:= stringToCheck,
		searchString		:= start,
		lengthStringToCheck	:= lengthStringToCheck,
		lengthSearchString	:= lengthOfStart,
		additionalText		:= THIS^.getDebugInfo('startsWith'),
		message				:= message
	)
) THEN
	RETURN;
END_IF

usedStringToCheck := THIS^.getNewUpperCaseString(stringToCheck, lengthStringToCheck, ignoreCases, sbcsType := sbcsType);
usedStartString := THIS^.getNewUpperCaseString(start, lengthOfStart, ignoreCases, sbcsType := sbcsType);

IF (Tc2_System.MEMCMP(
		usedStringToCheck,
		usedStartString, 
		lengthOfStart
	) <> CNM_ReturnTypes.ComparationResult.EQUAL
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('startsWith'));
END_IF;

THIS^.freeMemory(usedStringToCheck, ignoreCases);
THIS^.freeMemory(usedStartString, ignoreCases);		
]]></ST>
      </Implementation>
    </Method>
    <Method Name="trimLeft" Id="{53db1faf-8993-40cd-96a3-5954d47f0328}" FolderPath="protected\">
      <Declaration><![CDATA[(*

## Short summary
This method is used to remove the whitespace from the start of the string.
It does not really remove it, it just moves the start address and decreases
the string length

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD PROTECTED trimLeft
VAR_IN_OUT
	(* start address of the string *)
	stringAddress	:POINTER TO BYTE;
	(* length of the string ``stringAddress`` *)
	stringLength	:UDINT;
END_VAR
VAR_INPUT
	(* ``TRUE`` means remove the whitespace, ``FALSE`` means do not remove the whitespace *)
	trimString		:BOOL;
END_VAR
VAR
	(* index of the current character *)
	character		:UDINT;
	(* counter of the whitspace characters *)
	whitespaceCount	:UDINT;
	(* highest search index in the string *)
	maxSearchIndex :UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT trimString OR_ELSE stringAddress = 0 OR_ELSE stringLength <= 0);
maxSearchIndex := stringLength - 1;
FOR character := 0 TO maxSearchIndex DO
	IF NOT (THIS^.isCharWhiteSpace(stringAddress[character])) THEN
		EXIT;
	END_IF
	whitespaceCount := whitespaceCount + 1;
END_FOR

stringAddress := stringAddress + whitespaceCount;
stringLength := stringLength - whitespaceCount;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="trimRight" Id="{939afb9b-c414-42c8-bc76-ffa40b992b5c}" FolderPath="protected\">
      <Declaration><![CDATA[(*

## Short summary
This method is used to remove the whitespace from the end of the string.
It does not really remove it, it just decreases the string length.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD PROTECTED trimRight
VAR_INPUT
	(* start address of the string *)
	stringAddress	:POINTER TO BYTE;
END_VAR
VAR_IN_OUT
	(* length of the string ``stringAddress`` *)
	stringLength	:UDINT;
END_VAR
VAR_INPUT
	(* ``TRUE`` means remove the whitespace, ``FALSE`` means do not remove the whitespace *)
	trimString		:BOOL;
END_VAR
VAR
	(* index of the current character *)
	character	:LINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN(NOT trimString OR_ELSE stringAddress = 0 OR_ELSE stringLength <= 0);

character := stringLength;
WHILE(character >=0) DO
	RETURN (NOT THIS^.isCharWhiteSpace(stringAddress[character := character-1]));
	stringLength := stringLength-1;
END_WHILE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="upperCase" Id="{086dd677-43f2-4516-aa31-8d2a11cf9d64}" FolderPath="protected\">
      <Declaration><![CDATA[(*

## Short summary
This method converts the lowercase letters in an 8 bit windows-1252 or windows-1251
string to uppercase letters.

**Attention:** 
	All strings are handled as null-terminated byte streams.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD PROTECTED upperCase
VAR_INPUT
	(* string to ucase *)
	stringAddress	:POINTER TO BYTE;
	(* length of the string *)
	stringLength	:UDINT;
	(* used Single Byte Character Set (SBCS), is set in Tc2_Utilities.GLOBAL_SBCS_TABLE *)
	sbcsType 		:Tc2_Utilities.E_SBCSType := Tc2_Utilities.E_SBCSType.eSBCS_WesternEuropean;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (stringAddress = 0);

CASE sbcsType OF
Tc2_Utilities.E_SBCSType.eSBCS_WesternEuropean:
	upperCase1252(stringAddress, stringLength);
	
Tc2_Utilities.E_SBCSType.eSBCS_CentralEuropean:
	upperCase1251(stringAddress, stringLength);
ELSE
	; // do nothing
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="upperCase1251" Id="{bebe87ca-275f-4d97-8f5d-c55b150984d0}" FolderPath="protected\">
      <Declaration><![CDATA[(*

## Short summary
This method converts the lowercase letters in an 8 bit windows-1251
string to uppercase letters.

**Attention:** 
	All strings are handled as null-terminated byte streams.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD PROTECTED upperCase1251
VAR_INPUT
	(* string to ucase *)
	stringAddress		:POINTER TO BYTE;
	(* length of the string *)
	stringLength		:UDINT;
END_VAR
VAR
	(* index of the current character *)
	character			:UDINT := 0;
END_VAR
VAR CONSTANT
	(* NUL: $00 *)
	END_OF_STRING							:BYTE := 16#00;
	(* a *)                             	
	LOWERCASE_A								:BYTE := 16#61;
	(* z *)                             	
	LOWERCASE_Z								:BYTE := 16#7A;	
	(* а *)
	LOWERCASE_CYRILLIC_A					:BYTE := 16#E0;
	(* я *)
	LOWERCASE_CYRILLIC_YA					:BYTE := 16#FF;
	
	(* ђ *)
	LOWERCASE_CYRILLIC_DJE					:BYTE := 16#90;
	(* љ *)
	LOWERCASE_CYRILLIC_LJE					:BYTE := 16#9A;
	(* њ *)
	LOWERCASE_CYRILLIC_NJE					:BYTE := 16#9C;	
	(* џ *)
	LOWERCASE_CYRILLIC_DZHE					:BYTE := 16#9F;
	(* ё *)
	LOWERCASE_CYRILLIC_IO					:BYTE := 16#B8;
	(* є *)
	LOWERCASE_CYRILLIC_UKRAINIAN_IE			:BYTE := 16#BA;
	(* ї *)
	LOWERCASE_CYRILLIC_YI					:BYTE := 16#BF;

	(* ў *)
	LOWERCASE_CYRILLIC_SHORT_U				:BYTE := 16#A2;
	(* i *)
	LOWERCASE_CYRILLIC_UKRAINIAN_I			:BYTE := 16#B3;
	(* ѕ *)
	LOWERCASE_CYRILLIC_DZE					:BYTE := 16#BE;
	
	(* ѓ *)
	LOWERCASE_CYRILLIC_GJE					:BYTE := 16#83;
	
	(* ґ *)
	LOWERCASE_CYRILLIC_GHE_WITH_UPTURN		:BYTE := 16#B4;
	
	(* ј *)
	LOWERCASE_CYRILLIC_JE					:BYTE := 16#19;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[WHILE stringAddress[character] <> END_OF_STRING AND_THEN character <= stringLength DO
	CASE stringAddress[character] OF
	LOWERCASE_A..LOWERCASE_Z,
	LOWERCASE_CYRILLIC_A..LOWERCASE_CYRILLIC_YA:
		stringAddress[character] := stringAddress[character] - 16#20;
	LOWERCASE_CYRILLIC_DJE,
	LOWERCASE_CYRILLIC_LJE,
	LOWERCASE_CYRILLIC_NJE..LOWERCASE_CYRILLIC_DZHE,
	LOWERCASE_CYRILLIC_IO,
	LOWERCASE_CYRILLIC_UKRAINIAN_IE,
	LOWERCASE_CYRILLIC_YI:
		stringAddress[character] := stringAddress[character] - 16#10;
	LOWERCASE_CYRILLIC_SHORT_U,
	LOWERCASE_CYRILLIC_UKRAINIAN_I,
	LOWERCASE_CYRILLIC_DZE:
		stringAddress[character] := 16#01;
	LOWERCASE_CYRILLIC_GJE:
		stringAddress[character] := 16#02;
	LOWERCASE_CYRILLIC_GHE_WITH_UPTURN:
		stringAddress[character] := 16#0F;
	LOWERCASE_CYRILLIC_JE:
		stringAddress[character] := 16#0F;
	ELSE
		; // do nothing
	END_CASE
	
	character := character + 1;
END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="upperCase1252" Id="{e60c203d-c3e7-4684-a916-128389f29f69}" FolderPath="protected\">
      <Declaration><![CDATA[(*

## Short summary
This method converts the lowercase letters in an 8 bit windows-1252 
string to uppercase letters.

**Attention:** 
	All strings are handled as null terminated byte streams.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD PROTECTED upperCase1252
VAR_INPUT
	(* string to ucase *)
	stringAddress		:POINTER TO BYTE;
	(* length of the string *)
	stringLength		:UDINT;
END_VAR
VAR
	(* index of the current character *)
	character			:UDINT := 0;
END_VAR
VAR CONSTANT
	(* NUL: $00 *)
	END_OF_STRING							:BYTE := 16#00;
	(* a *)                             	
	LOWERCASE_A								:BYTE := 16#61;
	(* z *)                             	
	LOWERCASE_Z								:BYTE := 16#7A;
	(* ß *)                             	
	LOWERCASE_SHARP_S						:BYTE := 16#DF;
	(* ÿ *)                             	
	LOWERCASE_Y_WITH_DIAERESIS				:BYTE := 16#FF;
	(* Ÿ *)                             	
	UPPERCASE_Y_WITH_DIAERESIS				:BYTE := 16#9F;
	(* à *)                             	
	LOWERCASE_A_WITH_GRAVE					:BYTE := 16#E0;
	(* ö *)                             	
	LOWERCASE_O_WITH_DIAERESIS				:BYTE := 16#F6;
	(* ø *)                             	
	LOWERCASE_O_WITH_SLASH					:BYTE := 16#F8;
	(* þ *)                             	
	LOWERCASE_THORN							:BYTE := 16#FE;
	(* š *)                             	
	LOWERCASE_S_WITH_CARON					:BYTE := 16#9A;
	(* œ *)                             	
	LOWERCASE_OE							:BYTE := 16#9C;
	(* ž *)                             	
	LOWERCASE_Z_WITH_CARON					:BYTE := 16#9E;
	(* difference between lowercase and uppercase except for š,œ and ž *)
	DIFFERENCE_LOWERCASE_UPPERCASE			:BYTE := 16#20;
	(* for š,œ and ž the difference between lowercase and uppercase *)
	DIFFERENCE_LOWERCASE_UPPERCASE_SPECIAL	:BYTE := 16#10;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[WHILE stringAddress[character] <> END_OF_STRING AND_THEN character <= stringLength DO
	CASE stringAddress[character] OF
	LOWERCASE_A..LOWERCASE_Z,
	LOWERCASE_A_WITH_GRAVE..LOWERCASE_O_WITH_DIAERESIS,
	LOWERCASE_O_WITH_SLASH..LOWERCASE_THORN:
		stringAddress[character] := stringAddress[character] - DIFFERENCE_LOWERCASE_UPPERCASE;
	LOWERCASE_S_WITH_CARON,
	LOWERCASE_OE,
	LOWERCASE_Z_WITH_CARON:
		stringAddress[character] := stringAddress[character] - DIFFERENCE_LOWERCASE_UPPERCASE_SPECIAL;
	LOWERCASE_Y_WITH_DIAERESIS:
		stringAddress[character] := UPPERCASE_Y_WITH_DIAERESIS;
	LOWERCASE_SHARP_S:;//for ß do nothing, because there is no capital letter for it
	ELSE
		;
	END_CASE
	
	character := character + 1;
END_WHILE]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="Windows125xStringPointerAssertions">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.className.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.contains">
      <LineId Id="5" Count="17" />
      <LineId Id="39" Count="1" />
      <LineId Id="42" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="23" Count="15" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.containsNo">
      <LineId Id="5" Count="33" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.endsWith">
      <LineId Id="5" Count="3" />
      <LineId Id="36" Count="0" />
      <LineId Id="9" Count="26" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.freeMemory">
      <LineId Id="6" Count="2" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.getNewUpperCaseString">
      <LineId Id="3" Count="4" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.getStringCopy">
      <LineId Id="3" Count="7" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.getStringLength">
      <LineId Id="12" Count="0" />
      <LineId Id="5" Count="4" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.isCharWhiteSpace">
      <LineId Id="3" Count="5" />
      <LineId Id="2" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.isEqualTo">
      <LineId Id="5" Count="22" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.isNotEqualTo">
      <LineId Id="5" Count="11" />
      <LineId Id="28" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="17" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.lengthIsBetween">
      <LineId Id="5" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.lengthIsExact">
      <LineId Id="5" Count="1" />
      <LineId Id="2" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.lengthIsMax">
      <LineId Id="5" Count="1" />
      <LineId Id="2" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.lengthIsMin">
      <LineId Id="5" Count="1" />
      <LineId Id="2" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.startsWith">
      <LineId Id="5" Count="3" />
      <LineId Id="36" Count="0" />
      <LineId Id="9" Count="26" />
      <LineId Id="2" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.trimLeft">
      <LineId Id="5" Count="4" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="13" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.trimRight">
      <LineId Id="6" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="15" Count="1" />
      <LineId Id="19" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.upperCase">
      <LineId Id="5" Count="7" />
      <LineId Id="15" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.upperCase1251">
      <LineId Id="3" Count="21" />
      <LineId Id="28" Count="1" />
      <LineId Id="25" Count="2" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Windows125xStringPointerAssertions.upperCase1252">
      <LineId Id="3" Count="12" />
      <LineId Id="19" Count="1" />
      <LineId Id="16" Count="2" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>