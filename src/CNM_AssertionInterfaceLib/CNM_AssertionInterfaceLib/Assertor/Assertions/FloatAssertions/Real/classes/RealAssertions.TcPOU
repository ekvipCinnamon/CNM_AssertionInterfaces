<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.12">
  <POU Name="RealAssertions" Id="{4075a3a7-d344-4366-ab18-03d825ecb56e}" SpecialFunc="None">
    <Declaration><![CDATA[(*

## Short summary
This class provides assert statements for 32 bit floatings (``REAL``).
It implements the interface `IRealAssertions`

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

{attribute 'reflection'}
FUNCTION_BLOCK INTERNAL RealAssertions EXTENDS AbstractAssertion IMPLEMENTS IRealAssertions
VAR
END_VAR
VAR CONSTANT
	(* mask for determining value as a special value *)
	MASK_FOR_EXPONENT 	:DWORD := 16#7F80_0000;
	(* mask for determining a special value as NaN or infinite *)  
	MASK_FOR_FRACTION	:DWORD := 16#007F_FFFF;
	(* mask to get the sign bit of an infinite or zero value *)
	MASK_FOR_SIGN_BIT	:DWORD := 16#8000_0000;
	(* just to compare results or the memory of a float value *)
	ZERO				:DWORD := 16#0000_0000;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="internal" Id="{9b5a21f9-50fb-4066-bc95-f4055f2f4c7d}" />
    <Property Name="className" Id="{110d9f83-5196-40f7-a8f8-c92f095c55d5}">
      <Declaration><![CDATA[(*

## Short summary
This abstract property returns the class name of the concrete object, 
It's for debugging purpose

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

PROPERTY className :CNM_AbstractObject.ClassName]]></Declaration>
      <Get Name="Get" Id="{25f10bab-093b-4e1b-a4c8-fc6f9ae1e654}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[className := 'CNM_Assertor.RealAssertions';
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="isValueInfinite" Id="{815271fd-453a-4747-8b1d-6aeb8d232960}" FolderPath="internal\">
      <Declaration><![CDATA[(*

## Short summary
This method checks if a value is infinite
(infinity OR -inifinity), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>


:return: 
``TRUE``: value is inifinty or -infinity
``FALSE``: value is not inifinty and not -infinity

*)

METHOD PROTECTED isValueInfinite :BOOL
VAR_INPUT
	(* value to check *)
	value			:REAL;	
END_VAR
VAR
	(* just to cast the value*)
	realAsDword	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[realAsDword := ADR(value);
isValueInfinite := (
	THIS^.isValueSpecial(value)
	AND_THEN ((realAsDword^ AND THIS^.MASK_FOR_FRACTION) = THIS^.ZERO)
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isValueNaN" Id="{1b6a5f42-d917-4473-a294-9723909489b5}" FolderPath="internal\">
      <Declaration><![CDATA[(*

## Short summary
This method checks if a value is not a number
(NaN), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>


:return: 
``TRUE``: value is NaN
``FALSE``: value is not NaN

*)

METHOD PROTECTED isValueNaN :BOOL
VAR_INPUT
	(* value to check *)
	value			:REAL;	
END_VAR
VAR
	(* just to cast the value*)
	realAsDword	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[realAsDword := ADR(value);
isValueNaN := (
	THIS^.isValueSpecial(value)
	AND_THEN ((realAsDword^ AND THIS^.MASK_FOR_FRACTION) > THIS^.ZERO)
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isValueNegativeInfinite" Id="{bd6d20f3-d12a-4d15-8fc1-50d4adbb55f7}" FolderPath="internal\">
      <Declaration><![CDATA[(*

## Short summary
This method checks if a value is negative infinite
(-inifinity), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>


:return: 
``TRUE``: value is -infinity
``FALSE``: value is not -infinity

*)

METHOD PROTECTED isValueNegativeInfinite : BOOL
VAR_INPUT
	(* value to check *)
	value			:REAL;	
END_VAR
VAR
	(* just to cast the value*)
	realAsDword	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[realAsDword := ADR(value);
isValueNegativeInfinite := (
	THIS^.isValueInfinite(value)
	AND_THEN ((realAsDword^ AND THIS^.MASK_FOR_SIGN_BIT) = THIS^.MASK_FOR_SIGN_BIT)
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isValuePositiveInfinite" Id="{f5b97f96-5e04-48a8-b304-723a470e3f06}" FolderPath="internal\">
      <Declaration><![CDATA[(*

## Short summary
This method checks if a value is positive infinite
(infinity), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>


:return: 
``TRUE``: value is inifinty
``FALSE``: value is not inifinty

*)

METHOD PROTECTED isValuePositiveInfinite :BOOL
VAR_INPUT
	(* value to check *)
	value			:REAL;	
END_VAR
VAR
	(* just to cast the value*)
	realAsDword	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[realAsDword := ADR(value);
isValuePositiveInfinite := (
	THIS^.isValueInfinite(value)
	AND_THEN ((realAsDword^ AND THIS^.MASK_FOR_SIGN_BIT) = THIS^.ZERO)
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isValueSpecial" Id="{1c7e00db-3cd4-43a7-9f70-6426dab3ed41}" FolderPath="internal\">
      <Declaration><![CDATA[(*

## Short summary
This method checks if a value is a special value
(NaN OR infinity OR -inifinity), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>


:return: 
``TRUE``: value is inifinty or -infinity or NaN
``FALSE``: value is not inifinty and not -infinity and not NaN

*)

METHOD PROTECTED isValueSpecial :BOOL
VAR_INPUT
	(* value to check *)
	value			:REAL;	
END_VAR
VAR
	(* just to cast the value*)
	realAsDword	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[realAsDword := ADR(value);
isValueSpecial := ((realAsDword^ AND THIS^.MASK_FOR_EXPONENT) = THIS^.MASK_FOR_EXPONENT);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsANumber" Id="{709dd568-fc6a-4afc-8e25-eb28fbaed59b}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is a number (NOT NaN)
for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsANumber
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsANumber'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsEqualTo" Id="{f84f1d68-7a08-4c1f-9083-9a614eabfdf6}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is equal to the expected value

**Attention:** 
	Nothing is equal to NaN, that means if ``currentValue`` OR ``expectedValue`` OR ``tolerance``
	is NaN then is the assertion false. For details check `IEEE 754`_

**Attention:** 
	infinity is equal to infinity and -infinity is equal to -infinity, that means if
	``currentValue`` AND ``expectedValue`` have the value infinity 
	OR ``currentValue`` AND ``expectedValue`` have the value -infinity
	the assertion is TRUE. For details check `IEEE 754`_

**Attention:** 
	If ``tolerance`` has the value infinity or -infinity and 
	``currentValue`` is not NaN and ``expectedValue`` is not NaN
	then is the assertion true. for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsEqualTo
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* expected value to compare *)
	expectedValue	:REAL;
	(* tolerance to compensate twiddling floats, it has no sign *)
	tolerance		:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (
	THIS^.isValueNaN(currentValue)
	OR_ELSE THIS^.isValueNaN(expectedValue)
	OR_ELSE THIS^.isValueNaN(tolerance)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsEqualTo'));
ELSIF (THIS^.isValueInfinite(tolerance)) THEN
	RETURN;
ELSIF (
	THIS^.isValueInfinite(currentValue)
	OR_ELSE THIS^.isValueInfinite(expectedValue)
	OR_ELSE THIS^.isValueInfinite(tolerance)
) THEN
	RETURN (THIS^.isValuePositiveInfinite(currentValue) AND_THEN THIS^.isValuePositiveInfinite(expectedValue));
	RETURN (THIS^.isValueNegativeInfinite(currentValue) AND_THEN THIS^.isValueNegativeInfinite(expectedValue));
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsEqualTo'));	
ELSIF (ABS(currentValue-expectedValue) > ABS(tolerance)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsEqualTo'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsFinite" Id="{f1cb7e5e-cc50-4c87-a7eb-83cadc17b06c}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is finite
(NOT (infinity OR -inifinity)), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsFinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsFinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsGreaterThan" Id="{cd597d17-f21e-4e14-8472-e0703c59f17f}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is greater than the less value

**Attention:** 
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue`` OR ``lessValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_ and the truth table below.

**Attention:** 
	Every number is smaller than infinity except infinity, it's equal.
	Every number is greater than -infinity except -infinity, it's equal.
	For details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) and the truth table below.


truth table for special values
===============================
+----------------------+-------------------+---------------+
| **``currentValue``** | **``lessValue``** | **assertion** |
+======================+===================+===============+
| NaN                  | Any value         | FASLE         |
+----------------------+-------------------+---------------+
| Any value            | NaN               | FALSE         |
+----------------------+-------------------+---------------+
| infinity             | NOT NaN           | TRUE          |
|                      | NOT infinity      |               |
+----------------------+-------------------+---------------+
| -infinity             | Any value         | FALSE         |
+----------------------+-------------------+---------------+
| Any value            | infinity          | FALSE         |
+----------------------+-------------------+---------------+
| NOT NaN              | -inifinity        | TRUE          |
| NOT -infinity        |                   |               |
+----------------------+-------------------+---------------+

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsGreaterThan
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* less than lower limit *)
	lessValue		:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (
	THIS^.isValueNaN(currentValue) 
	OR_ELSE THIS^.isValueNaN(lessValue)
	OR_ELSE THIS^.isValueNegativeInfinite(currentValue) 
	OR_ELSE THIS^.isValuePositiveInfinite(lessValue)
)THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsGreaterThan'));
ELSIF (
	THIS^.isValueNegativeInfinite(lessValue)
	OR_ELSE THIS^.isValuePositiveInfinite(currentValue)
) THEN
	RETURN;
ELSIF (currentValue <= lessValue) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsGreaterThan'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsInfinite" Id="{8bb571d6-fffc-4c06-8094-a5b1b9984123}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is infinite
(infinity OR -inifinity), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsInfinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT THIS^.isValueInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInfinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsInRangeOf" Id="{02f55ee9-3bcf-4a32-bca7-d602c6776919}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is inside a limit

**Attention:** 
	limits are included: ``valueIsInRangeOf(3.0, 3.0, 3.0)`` is a true assertion

**Attention:** 
	Any comparsion to NaN is ``FALSE`` that means 
	if ``lowerLimit`` OR ``currentValue`` OR ``upperLimit``
	is NaN then is the assertion false.
	For details check `IEEE 754`_ and the truth table below.

**Attention:** 
	Every number is smaller than infinity except infinity, it's equal.
	Every number is greater than -infinity except -infinity, it's equal.
	For details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) and the truth table below.


truth table for special values
===============================
+--------------------+----------------------+--------------------+---------------+
| **``lowerLimit``** | **``currentValue``** | **``upperLimit``** | **assertion** |
+====================+======================+====================+===============+
| NaN                | Any value            | Any value          | FASLE         |
+--------------------+----------------------+--------------------+---------------+
| Any value          | NaN                  | Any value          | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| Any value          | Any value            | NaN                | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| -infinity          | NOT NaN              | infinity           | TRUE          |
+--------------------+----------------------+--------------------+---------------+
| infinity           | Any value            | -infinity          | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| NOT -infinity      | -infinity            | Any value          | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| Any value          | infinity             | NOT infinity       | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| -infinity          | -infinity            | -infinity          | TRUE          |
+--------------------+----------------------+--------------------+---------------+
| infinity           | infinity             | infinity           | TRUE          |
+--------------------+----------------------+--------------------+---------------+
| -infinity          | NOT -infinity        | -infinity          | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| infinity           | NOT infinity         | infinity           | FALSE         |
+--------------------+----------------------+--------------------+---------------+

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsInRangeOf
VAR_INPUT
	(* lower limit for the current value *)
	lowerLimit		:REAL;
	(* current value to check *)
	currentValue	:REAL;
	(* upper limit for the current value *)
	upperLimit		:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (
	THIS^.isValueNaN(lowerLimit)
	OR_ELSE THIS^.isValueNaN(currentValue)
	OR_ELSE THIS^.isValueNaN(upperLimit)
	OR_ELSE (
		THIS^.isValueNegativeInfinite(upperLimit) 
		AND_THEN THIS^.isValuePositiveInfinite(lowerLimit)
	) OR_ELSE (	
		THIS^.isValueNegativeInfinite(currentValue) 
		AND_THEN (NOT THIS^.isValueNegativeInfinite(lowerLimit))
	) OR_ELSE (
		THIS^.isValuePositiveInfinite(currentValue) 
		AND_THEN (NOT THIS^.isValuePositiveInfinite(upperLimit))
	) OR_ELSE (
		THIS^.isValuePositiveInfinite(lowerLimit)
		AND_THEN (NOT THIS^.isValuePositiveInfinite(currentValue))
		AND_THEN THIS^.isValuePositiveInfinite(upperLimit)
	) OR_ELSE (
		THIS^.isValueNegativeInfinite(lowerLimit)
		AND_THEN (NOT THIS^.isValueNegativeInfinite(currentValue))
		AND_THEN THIS^.isValueNegativeInfinite(upperLimit))
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInRangeOf'));
ELSIF ((
		THIS^.isValuePositiveInfinite(lowerLimit)
		AND_THEN THIS^.isValuePositiveInfinite(currentValue)
		AND_THEN THIS^.isValuePositiveInfinite(upperLimit)
	) OR_ELSE (
		THIS^.isValueNegativeInfinite(lowerLimit)
		AND_THEN THIS^.isValueNegativeInfinite(currentValue)
		AND_THEN THIS^.isValueNegativeInfinite(upperLimit)
	) OR_ELSE (
		THIS^.isValueNegativeInfinite(lowerLimit) 
		AND_THEN THIS^.isValuePositiveInfinite(upperLimit))
) THEN
	RETURN;
ELSIF ((currentValue < lowerLimit) OR (currentValue > upperLimit)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInRangeOf'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsLessThan" Id="{2997a92f-abab-4ef5-95d2-154c21a84b03}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is greater than the less value

**Attention:**
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue`` OR ``greaterValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_ and the truth table below.

**Attention:**
	Every number is smaller than infinity except infinity, it's equal.
	Every number is greater than -infinity except -infinity, it's equal.
	For details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) and the truth table below.


truth table for special values
===============================
+----------------------+----------------------+---------------+
| **``currentValue``** | **``greaterValue``** | **assertion** |
+======================+======================+===============+
| NaN                  | Any value            | FASLE         |
+----------------------+----------------------+---------------+
| Any value            | NaN                  | FALSE         |
+----------------------+----------------------+---------------+
| infinity             | Any value            | FALSE         |
+----------------------+----------------------+---------------+
| -infinity             | NOT NaN              | TRUE          |
|                      | NOT -infinity        |               |
+----------------------+----------------------+---------------+
| NOT NaN              | infinity             | TRUE          |
| NOT infinity         |                      |               |
+----------------------+----------------------+---------------+

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsLessThan
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* greater than upper limit *)
	greaterValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (
	THIS^.isValueNaN(currentValue) 
	OR_ELSE THIS^.isValueNaN(greaterValue)
	OR_ELSE THIS^.isValuePositiveInfinite(currentValue)
	OR_ELSE THIS^.isValueNegativeInfinite(greaterValue)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsLessThan'));
ELSIF (
	THIS^.isValuePositiveInfinite(greaterValue)
	OR_ELSE THIS^.isValueNegativeInfinite(currentValue)
) THEN
	RETURN;
ELSIF (currentValue >= greaterValue) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsLessThan'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsMax" Id="{98a0980d-8eb8-4d2c-b23a-734e2b6d4ce1}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is less than or equal to the maximum value

**Attention:**
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue`` OR ``maximumValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_ and the truth table below.

**Attention:**
	Every number is smaller than infinity except infinity, it's equal.
	Every number is greater than -infinity except -infinity, it's equal.
	For details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) and the truth table below.


truth table for special values
===============================
+----------------------+----------------------+---------------+
| **``currentValue``** | **``maximumValue``** | **assertion** |
+======================+======================+===============+
| NaN                  | Any value            | FASLE         |
+----------------------+----------------------+---------------+
| Any value            | NaN                  | FALSE         |
+----------------------+----------------------+---------------+
| NOT NaN              | infinity             | TRUE          |
+----------------------+----------------------+---------------+
| -infinity            | NOT NaN              | TRUE          |
+----------------------+----------------------+---------------+
| infinity             | NOT infinity         | FALSE         |
+----------------------+----------------------+---------------+
| NOT -infinity        | -infinity            | FALSE         |
+----------------------+----------------------+---------------+

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsMax
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* upper limit for the current value *)
	maximumValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (
	THIS^.isValueNaN(currentValue) 
	OR_ELSE THIS^.isValueNaN(maximumValue)
	OR_ELSE (
		THIS^.isValueNegativeInfinite(maximumValue)
		AND_THEN (NOT THIS^.isValueNegativeInfinite(currentValue))
	) OR_ELSE (
		THIS^.isValuePositiveInfinite(currentValue)
		AND_THEN (NOT THIS^.isValuePositiveInfinite(maximumValue))
	)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMax'));
ELSIF (
	THIS^.isValuePositiveInfinite(maximumValue)
	OR_ELSE THIS^.isValueNegativeInfinite(currentValue)
) THEN
	RETURN;
ELSIF (currentValue > maximumValue) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMax'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsMin" Id="{8bdcaaad-54e1-401d-b7fd-ad8ef23f4662}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is greater than or equal to the minimum value

**Attention:**
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue`` OR ``minimumValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_ and the truth table below.

**Attention:**
	Every number is smaller than infinity except infinity, it's equal.
	Every number is greater than -infinity except -infinity, it's equal.
	For details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) and the truth table below.


truth table for special values
===============================
+----------------------+----------------------+---------------+
| **``currentValue``** | **``minimumValue``** | **assertion** |
+======================+======================+===============+
| NaN                  | Any value            | FASLE         |
+----------------------+----------------------+---------------+
| Any value            | NaN                  | FALSE         |
+----------------------+----------------------+---------------+
| infinity             | NOT NaN              | TRUE          |
+----------------------+----------------------+---------------+
| NOT NaN              | -infinity            | TRUE          |
+----------------------+----------------------+---------------+
| -infinity            | NOT -infinity        | FALSE         |
+----------------------+----------------------+---------------+
| NOT infinity         | infinity             | FALSE         |
+----------------------+----------------------+---------------+

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsMin
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* lower limit for the current value *)
	minimumValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (
	THIS^.isValueNaN(currentValue) 
	OR_ELSE THIS^.isValueNaN(minimumValue)
	OR_ELSE (
		THIS^.isValueNegativeInfinite(currentValue)
		AND_THEN (NOT THIS^.isValueNegativeInfinite(minimumValue))
	) OR_ELSE (
		THIS^.isValuePositiveInfinite(minimumValue)
		AND_THEN (NOT THIS^.isValuePositiveInfinite(currentValue))
	)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMin'));
ELSIF (
	THIS^.isValuePositiveInfinite(currentValue)
	OR_ELSE THIS^.isValueNegativeInfinite(minimumValue)
) THEN
	RETURN;
ELSIF (currentValue < minimumValue) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMin'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNaN" Id="{fc26c4f5-ec39-4c76-a036-66bde40b41c8}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is a not a number (NaN)
for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsNaN
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT THIS^.isValueNaN(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNaN'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNegative" Id="{acc8447d-cf51-4bac-ba7f-59342219593a}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is negative

**Attention:**
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_.

**Attention:**
	``currentValue`` has the value infinity means the assertion is false.
	``currentValue`` has the value -infinity means the assertion is true.
	``currentValue`` has the +0.0 means the assertion is false.
	``currentValue`` has the value -0.0 means the assertion is true.	
		For details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754).


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsNegative
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue)) THEN	
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNegative'));
ELSE
	currentValueAsDWord := ADR(currentValue);
	IF ((currentValueAsDWord^ AND THIS^.MASK_FOR_SIGN_BIT) = THIS^.ZERO) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNegative'));
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNegativeInfinite" Id="{23407c25-c3f6-4850-9fb2-253dc72a9f05}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is negative infinite
(-infinity), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsNegativeInfinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT THIS^.isValueNegativeInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNegativeInfinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNegativeZero" Id="{633b0bca-b28f-414c-8313-f7c07197635e}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is -0.0
for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsNegativeZero
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[currentValueAsDWord := ADR(currentValue);
IF (currentValueAsDWord^ <> THIS^.MASK_FOR_SIGN_BIT) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNegativeZero'));
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNormal" Id="{d22ed2a4-89ae-4279-85c2-043e0051c3f3}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is a normal number
(a finite non-zero/non-subnormal floating-point number)
for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsNormal
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue) OR_ELSE THIS^.isValueInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNormal'));
ELSE
	currentValueAsDWord := ADR(currentValue);
	IF ((currentValueAsDWord^ AND THIS^.MASK_FOR_EXPONENT) = THIS^.ZERO) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNormal'));
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNotEqualTo" Id="{cc528cc3-817d-46ff-ae2e-a0526988dcce}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is not equal to the unexpected value

**Attention:** 
	Nothing is equal to NaN, that means if ``currentValue`` OR ``unexpectedValue`` OR ``tolerance``
	is NaN then is the assertion true. For details check `IEEE 754`_

**Attention:** 
	infinity is equal to infinity and -infinity is equal to -infinity, that means if
	``currentValue`` AND ``unexpectedValue`` have the value infinity 
	OR ``currentValue`` AND ``unexpectedValue`` have the value -infinity
	the assertion is false. For details check `IEEE 754`_

**Attention:** 
	If ``tolerance`` has the value infinity or -infinity and 
	``currentValue`` is not NaN and ``unexpectedValue`` is not NaN
	then is the assertion false. for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsNotEqualTo
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* unexpected value to compare *)
	unexpectedValue	:REAL;
	(* tolerance to compensate twiddling floats, it has no sign *)
	tolerance		:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (
	THIS^.isValueNaN(currentValue)
	OR_ELSE THIS^.isValueNaN(unexpectedValue)
	OR_ELSE THIS^.isValueNaN(tolerance)
) THEN
	RETURN;
ELSIF (THIS^.isValueInfinite(tolerance)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotEqualTo'));
ELSIF (
	THIS^.isValueInfinite(currentValue)
	OR_ELSE THIS^.isValueInfinite(unexpectedValue)
) THEN
	RETURN (THIS^.isValuePositiveInfinite(currentValue) AND_THEN (NOT THIS^.isValuePositiveInfinite(unexpectedValue)));
	RETURN (THIS^.isValueNegativeInfinite(currentValue) AND_THEN (NOT THIS^.isValueNegativeInfinite(unexpectedValue)));
	RETURN (THIS^.isValuePositiveInfinite(unexpectedValue) AND_THEN (NOT THIS^.isValuePositiveInfinite(currentValue)));
	RETURN (THIS^.isValueNegativeInfinite(unexpectedValue) AND_THEN (NOT THIS^.isValueNegativeInfinite(currentValue)));
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotEqualTo'));
ELSIF (ABS(currentValue-unexpectedValue) <= ABS(tolerance)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotEqualTo'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNotNegativeInfinite" Id="{24c1beb1-733c-4e65-aa2b-1981611c1fab}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is not negative infinite
NOT (-infinity), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsNotNegativeInfinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNegativeInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotNegativeInfinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNotPositiveInfinite" Id="{d4d9443b-484d-4c97-a9a0-fd6ab2a9d9bc}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is not positive infinite
NOT (infinity), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsNotPositiveInfinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValuePositiveInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotPositiveInfinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNotSpecial" Id="{5af1017a-8b79-43ef-8eae-222de6f84645}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is a non special number
(NOT (NaN OR infinity OR -inifinity)), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsNotSpecial
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueSpecial(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotSpecial'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsPositive" Id="{a6752b6c-a25c-44cf-9758-5f963d8e39f3}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is positve

**Attention:**
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_.

**Attention:**
	``currentValue`` has the value infinity means the assertion is true.
	``currentValue`` has the value -infinity means the assertion is false.
	``currentValue`` has the +0.0 means the assertion is true.
	``currentValue`` has the value -0.0 means the assertion is false.	
		For details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754).


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsPositive
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue)) THEN	
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsPositive'));
ELSE
	currentValueAsDWord := ADR(currentValue);
	IF ((currentValueAsDWord^ AND THIS^.MASK_FOR_SIGN_BIT) = THIS^.MASK_FOR_SIGN_BIT) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsPositive'));
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsPositiveInfinite" Id="{810de819-859c-4aee-b9c5-3a1b94b6eb18}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is positive infinite
(infinity), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsPositiveInfinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT THIS^.isValuePositiveInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsPositiveInfinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsPositiveZero" Id="{4cbd5478-17ab-4595-8db6-8d0546732621}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is +0.0
for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsPositiveZero
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[currentValueAsDWord := ADR(currentValue);
IF (currentValueAsDWord^ <> THIS^.ZERO) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsPositiveZero'));
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsSpecial" Id="{1a91340a-aa5b-420c-8f43-9662764dd26e}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is a special
(NaN OR infinity OR -inifinity), for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsSpecial
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT THIS^.isValueSpecial(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsSpecial'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsSubnormal" Id="{9902eb9c-76db-490c-ae37-b6cf36aa8a62}">
      <Declaration><![CDATA[(*

## Short summary
This assertion method checks if the current value is a subnormal number
for details check [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)

METHOD valueIsSubnormal
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsSubnormal'));
ELSE
	currentValueAsDWord := ADR(currentValue);
	IF ((currentValueAsDWord^ AND THIS^.MASK_FOR_EXPONENT) <> THIS^.ZERO) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsSubnormal'));
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="RealAssertions">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.className.Get">
      <LineId Id="1" Count="1" />
    </LineIds>
    <LineIds Name="RealAssertions.isValueInfinite">
      <LineId Id="1" Count="5" />
    </LineIds>
    <LineIds Name="RealAssertions.isValueNaN">
      <LineId Id="1" Count="5" />
    </LineIds>
    <LineIds Name="RealAssertions.isValueNegativeInfinite">
      <LineId Id="1" Count="5" />
    </LineIds>
    <LineIds Name="RealAssertions.isValuePositiveInfinite">
      <LineId Id="1" Count="5" />
    </LineIds>
    <LineIds Name="RealAssertions.isValueSpecial">
      <LineId Id="1" Count="2" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsANumber">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsEqualTo">
      <LineId Id="1" Count="19" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsFinite">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsGreaterThan">
      <LineId Id="1" Count="15" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsInfinite">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsInRangeOf">
      <LineId Id="1" Count="39" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsLessThan">
      <LineId Id="1" Count="15" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsMax">
      <LineId Id="1" Count="20" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsMin">
      <LineId Id="1" Count="20" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNaN">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNegative">
      <LineId Id="1" Count="8" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNegativeInfinite">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNegativeZero">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNormal">
      <LineId Id="1" Count="8" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNotEqualTo">
      <LineId Id="1" Count="20" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNotNegativeInfinite">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNotPositiveInfinite">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNotSpecial">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsPositive">
      <LineId Id="1" Count="8" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsPositiveInfinite">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsPositiveZero">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsSpecial">
      <LineId Id="1" Count="3" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsSubnormal">
      <LineId Id="1" Count="8" />
    </LineIds>
  </POU>
</TcPlcObject>